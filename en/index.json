[{"categories":["professional writings"],"contents":"Install phpMyAdmin on Centos 8 Step 1: Install phpMyAdmin  The phpMyAdmin tool is not included in the default CentOS 8 repositories. However, the file can be download manually.  wget https://files.phpmyadmin.net/phpMyAdmin/4.9.4/phpMyAdmin-4.9.4-all-languages.zip  Extract the .zip file archive:  unzip phpMyAdmin-4.9.4-all-languages.zip  Move the extracted files to the /usr/share/phpmyadmin directory:  sudo mv phpMyAdmin-4.9.4-all-languages.zip /usr/share/phpmyadmin  Change directories:  cd /usr/share/phpmyadmin  Rename the sample php configuration file:  sudo mv config.sample.inc.php config.inc.php  Open the php configuration file for editing:  sudo nano config.inc.php  Find the following line:  $cfg['blowfish_secret'] = '';  Edit the line and enter the new php root password between the single-quotes, as follows:  $cfg['blowfish_secret']='my_password';  Next, create and set permissions on a temporary phpMyAdmin directory:  mkdir /usr/share/phpmyadmin/tmp chown -R apache:apache /usr/share/phpmyadmin chmod 777 /usr/share/phpmyadmin/tmp Step 2: Configure Apache for phpMyAdmin  Create an Apache configuration file:  sudo nano /etc/httpd/conf.d/phpmyadmin.conf  This creates a new, blank configuration file. Enter the following code:  Alias /phpmyadmin /usr/share/phpmyadmin \u0026lt;Directory /usr/share/phpmyadmin/\u0026gt; AddDefaultCharset UTF-8 \u0026lt;IfModule mod_authz_core.c\u0026gt; # Apache 2.4 \u0026lt;RequireAny\u0026gt; Require all granted \u0026lt;/RequireAny\u0026gt; \u0026lt;/IfModule\u0026gt; \u0026lt;IfModule !mod_authz_core.c\u0026gt; # Apache 2.2 Order Deny,Allow Deny from All Allow from 127.0.0.1 Allow from ::1 \u0026lt;/IfModule\u0026gt; \u0026lt;/Directory\u0026gt; \u0026lt;Directory /usr/share/phpmyadmin/setup/\u0026gt; \u0026lt;IfModule mod_authz_core.c\u0026gt; # Apache 2.4 \u0026lt;RequireAny\u0026gt; Require all granted \u0026lt;/RequireAny\u0026gt; \u0026lt;/IfModule\u0026gt; \u0026lt;IfModule !mod_authz_core.c\u0026gt; # Apache 2.2 Order Deny,Allow Deny from All Allow from 127.0.0.1 Allow from ::1 \u0026lt;/IfModule\u0026gt; \u0026lt;/Directory\u0026gt;   Save the file (Ctrl+o) and exit (Ctrl+x).\n  Finally, restart the Apache service to apply the changes made in the configuration file:\n  systemctl restart httpd Step 3: Configure SELinux and Firewall SELinux stands for Security-Enhanced Linux. This is a kernel-level enhancement that improves security. Reconfigure this protocol for phpMyAdmin to work.\n Start by installing the following software package:  yum -y install policycoreutils-python-utils Some versions of CentOS 8 may already have this package installed. In that case, the output indicates it has nothing to do and you can move on to the next step.\n Next, enable access to the phpmyadmin directory with the following commands:  semanage fcontext -a -t httpd_sys_rw_content_t '/usr/share/phpmyadmin/' semanage fcontext -a -t httpd_sys_rw_content_t \u0026quot;usr/share/phpmyadmin/tmp(/.*)?\u0026quot; restorecon -Rv '/usr/share/phpmyadmin/' The first two commands may take a moment to complete. The third command recurses through the phpmyadmin directory to apply the changes.\nAdjust the Firewall to Allow Traffic  Create a firewall rule to allow HTTP traffic with the command:  firewall-cmd --permanent --add-service=http  Make sure to reload the firewall after making these modifications:  firewall-cmd --reload Step 4: Test phpMyAdmin  Open a web browser, and navigate to the following URL:  localhost/phpmyadmin The browser should display the phpMyAdmin login page. However, if you attempt to log in, an error message may appear:\n\u0026quot;The server requested an authentication method unknown to the client.\u0026quot; This error occurs because MySQL 8.x upgraded the password authentication mechanism. PhpMyAdmin has not been updated yet to use this authentication method.\n To bypass this measure, open the MySQL shell and alter the root user:  mysql -u root -p password ALTER USER 'root'@'localhost' IDENTIFIED WITH myswl_native_password BY 'password';   Replace password with the actual password you set when securing the MySQL installation.\n  Refresh the web browser phpMyAdmin page, and log in with your MySQL username and password.\n  Step 5: Restrict Unauthorized Access to phpMyAdmin (Optional) You should now have a working phpMyAdmin utility. This section will help you prevent unauthorized access to sensitive databases. Allow phpMyAdmin Only From a Specific IP Address\n Open the phpmyadmin.conf file in a text editor (we will be using nano):  sudo nano /etc/httpd/conf.d/phpmyadmin.conf  Find the following sections:  Require all granted\n Replace these lines with the following:  Require ip your_system's_ip_address Require ip ::1  Save and close the file.  If you are using SELinux, check this out I was running CentOS 8 with SELinux enforcing, and I was getting an error (mysqli_real_connect(): (HY000/2002): No such file or directory) despite having all the configurations fixed correctly. I later got out of trouble after allowing MySQL connections through SELinux.\nCheck SELinux status using this command:\nsestatus Allow Apache to connect database through SELinux\nsetsebool httpd_can_network_connect_db 1 Use -P option makes the change permanent. Without this option, the boolean would be reset to 0 at reboot.\nsetsebool -P httpd_can_network_connect_db 1 Secure phpMyAdmin At this point, the phpMyAdmin instance is functioning properly. However, securing your phpMyAdmin instance from the outside world it an important task for you. In this section, we will show you how to secure your phpMyAdmin instance.\nAllow phpMyAdmin from Specific IP First, you will need to configure your phpMyAdmin to accessible only from your home connection\u0026rsquo;s IP address.\nYou can configure it by editing /etc/httpd/conf.d/phpmyadmin.conf file:\nnano /etc/httpd/conf.d/phpmyadmin.conf Find the following lines:\n \u0026lt;RequireAny\u0026gt; Require all granted \u0026lt;/RequireAny\u0026gt; And, replace them with the following:\n\u0026lt;RequireAny\u0026gt; Require ip your-home--connection-ip-address Require ip ::1 \u0026lt;/RequireAny\u0026gt; Save and close the file when you are finished.\nConfigure Extra Layer of Authentication It is a good idea to password protect your phpmyadmin directory by setting up a basic authentication.\nTo do so, create a new authentication file using the htpasswd tool as shown below:\nmkdir /etc/phpmyadmin htpasswd -c /etc/phpmyadmin/.htpasswd admin You will be asked to provide your admin password as shown below:\nNew password: Re-type new password: Adding password for user admin Next, you will need to configure Apache to use the .htpasswd file. You can do this by editing the file /etc/httpd/conf.d/phpmyadmin.conf.\nnano /etc/httpd/conf.d/phpmyadmin.conf Add the following lines below the line \u0026ldquo;AddDefaultCharset UTF-8\u0026rdquo;:\n Options +FollowSymLinks +Multiviews +Indexes AllowOverride None AuthType basic AuthName \u0026quot;Authentication Required\u0026quot; AuthUserFile /etc/phpmyadmin/.htpasswd Require valid-user Save the file and restart the Apache service for changes to take effect:\nsystemctl restart httpd Access phpMyAdmin Now, your phpMyAdmin instance is secured with an extra layer of security. Open your web browser and type the URL http://your-server-ip/phpmyadmin. You will be asked to enter the login credentials of the user you previously created.\nProvide your admin username and password, then click on the OK button. You will be redirected to the phpMyAdmin login page. Now, provide your MySQL administrative user login credentials and click on the Go button.\nস্নাপ সমস্যা: এসই লিনাক্সে স্নাপ সমস্যা করছিলো, কিছু ক্ষণ পরপর এলার্ট করে। এই লিংকে সমাধান আছে বলে মনে হলো: https://forum.snapcraft.io/t/centos-8-snapd-installation-selinux/14998/4\nThe solution is to enable the continuous release (CR) repository 41 since it contains the upcoming 8.1 packages.\nEnable CR repo:\n The repository configuration file is included in the newest centos-release package. First update your system with dnf update to get the new centos-release package, then run dnf config-manager \u0026ndash;enable cr to enable the CR repository.\n SELinux Alert Browser এ এই সাজেশন দিয়েছে: তা চালালাম:\nYou should report this as a bug. You can generate a local policy module to allow this access. Allow this access for now by executing: # ausearch -c 'snapd' --raw | audit2allow -M my-snapd # semodule -X 300 -i my-snapd.pp ","permalink":"https://arafat-hasan.github.io/en/post/lamp-config/","tags":["note","lamp","installation","centos"],"title":"LAMP Installation and Config"},{"categories":["professional writings"],"contents":" This writing is actually a draft note made for myself, so that I myself don’t forget what I had learned. But I think this note will be helpful for those who want to learn Redis. If you don’t know what Redis is, or haven’t installed Redis in your system yet, check it out here.\n 1. Hello World in Redis 1.1. PING Returns PONG if no argument is provided, otherwise return a copy of the argument as a bulk. This command is often used to test if a connection is still alive, or to measure latency.\n  1.2. ECHO Returns message.\n 1 2 3 4 5 6 7 [arafat@server ~]$ redis-cli 127.0.0.1:6379\u0026gt; PING PONG 127.0.0.1:6379\u0026gt; PING \u0026#34;hello world\u0026#34; \u0026#34;hello world\u0026#34; 127.0.0.1:6379\u0026gt; ECHO \u0026#34;Hello World!\u0026#34; \u0026#34;Hello World!\u0026#34;     1.3. SET Set key to hold the string value. If key already holds a value, it is overwritten, regardless of its type.\n  1.4. GET Get the value of key. If the key does not exist the special value nil is returned. An error is returned if the value stored at key is not a string, because GET only handles string values.\n 1 2 3 4 5 6 7 8 9 10 127.0.0.1:6379\u0026gt; SET foo 100 OK 127.0.0.1:6379\u0026gt; GET foo \u0026#34;100\u0026#34; 127.0.0.1:6379\u0026gt; SET bar \u0026#34;Hello World!\u0026#34; OK 127.0.0.1:6379\u0026gt; GET bar \u0026#34;Hello World!\u0026#34; 127.0.0.1:6379\u0026gt; GET nonexisting (nil)     1.5. INCR Increments the number stored at key by one. If the key does not exist, it is set to 0 before performing the operation. An error is returned if the key contains a value of the wrong type or contains a string that can not be represented as integer. This operation is limited to 64 bit signed integers.\n  1.6. DECR Decrements the number stored at key by one. If the key does not exist, it is set to 0 before performing the operation. An error is returned if the key contains a value of the wrong type or contains a string that can not be represented as integer. This operation is limited to 64 bit signed integers.\n 1 2 3 4 5 6 7 8 127.0.0.1:6379\u0026gt; INCR foo (integer) 101 127.0.0.1:6379\u0026gt; GET foo \u0026#34;101\u0026#34; 127.0.0.1:6379\u0026gt; DECR foo (integer) 100 127.0.0.1:6379\u0026gt; GET foo \u0026#34;100\u0026#34;     1.7. EXISTS Returns if key exists: - 1 if the key exists. - 0 if the key does not exist.\n  1.8. DEL Removes the specified keys. A key is ignored if it does not exist.\n 1 2 3 4 5 6 7 8 9 10 11 12 127.0.0.1:6379\u0026gt; EXISTS foo (integer) 1 127.0.0.1:6379\u0026gt; EXISTS nosuchkey (integer) 0 127.0.0.1:6379\u0026gt; EXISTS foo bar nosuchkey (integer) 2 127.0.0.1:6379\u0026gt; DEL bar (integer) 1 127.0.0.1:6379\u0026gt; EXISTS bar (integer) 0 127.0.0.1:6379\u0026gt; GET bar (nil)     1.9. FLUSHALL Delete all the keys of all the existing databases, not just the currently selected one. This command never fails.\n 1 2 3 4 5 127.0.0.1:6379\u0026gt; FLUSHALL OK 127.0.0.1:6379\u0026gt; GET foo (nil) 127.0.0.1:6379\u0026gt;     1.10. EXPIRE Set a timeout on key. After the timeout has expired, the key will automatically be deleted. A key with an associated timeout is often said to be volatile in Redis terminology.\n  1.11. TTL Returns the remaining time to live of a key that has a timeout. This introspection capability allows a Redis client to check how many seconds a given key will continue to be part of the dataset.\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 127.0.0.1:6379\u0026gt; SET greeting \u0026#34;Hello World!\u0026#34; OK 127.0.0.1:6379\u0026gt; EXPIRE greeting 50 (integer) 1 127.0.0.1:6379\u0026gt; TTL greeting (integer) 47 127.0.0.1:6379\u0026gt; TTL greeting (integer) 43 127.0.0.1:6379\u0026gt; TTL greeting (integer) 37 127.0.0.1:6379\u0026gt; TTL greeting (integer) 30 127.0.0.1:6379\u0026gt; TTL greeting (integer) 30 127.0.0.1:6379\u0026gt; TTL greeting (integer) 26 127.0.0.1:6379\u0026gt; TTL greeting (integer) 19 127.0.0.1:6379\u0026gt; TTL greeting (integer) 3 127.0.0.1:6379\u0026gt; TTL greeting (integer) -2 127.0.0.1:6379\u0026gt; TTL greeting (integer) -2     1.12. SETEX Set key to hold the string value and set key to timeout after a given number of seconds. This command is equivalent to executing the following commands:\n 1 2 SET mykey value EXPIRE mykey seconds     1.13. PERSIST Remove the existing timeout on key, turning the key from volatile (a key with an expire set) to persistent (a key that will never expire as no timeout is associated).\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 127.0.0.1:6379\u0026gt; SETEX greeting 30 \u0026#34;Hello World!\u0026#34; OK 127.0.0.1:6379\u0026gt; TTL greeting (integer) 26 127.0.0.1:6379\u0026gt; TTL greeting (integer) 21 127.0.0.1:6379\u0026gt; SETEX greeting 130 \u0026#34;Hello World!\u0026#34; OK 127.0.0.1:6379\u0026gt; TTL greeting (integer) 125 127.0.0.1:6379\u0026gt; PERSIST greeting (integer) 1 127.0.0.1:6379\u0026gt; TTL greeting (integer) -1 127.0.0.1:6379\u0026gt; GET greeting \u0026#34;Hello World!\u0026#34;     1.14. MSET Sets the given keys to their respective values. MSET replaces existing values with new values, just as regular SET. See MSETNX if you don’t want to overwrite existing values.\n  1.15. APPEND If key already exists and is a string, this command appends the value at the end of the string. If key does not exist it is created and set as an empty string, so APPEND will be similar to SET in this special case.\n  1.16. RENAME Renames key to newkey. It returns an error when key does not exist. If newkey already exists it is overwritten, when this happens RENAME executes an implicit DEL operation, so if the deleted key contains a very big value it may cause high latency even if RENAME itself is usually a constant-time operation.\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 127.0.0.1:6379\u0026gt; MSET key1 \u0026#34;Hello\u0026#34; key2 \u0026#34;world\u0026#34; OK 127.0.0.1:6379\u0026gt; GET key1 \u0026#34;Hello\u0026#34; 127.0.0.1:6379\u0026gt; GET key2 \u0026#34;world\u0026#34; 127.0.0.1:6379\u0026gt; APPEND key1 \u0026#34; world!\u0026#34; (integer) 12 127.0.0.1:6379\u0026gt; GET key1 \u0026#34;Hello world!\u0026#34; 127.0.0.1:6379\u0026gt; RENAME key1 greeting OK 127.0.0.1:6379\u0026gt; GET key1 (nil) 127.0.0.1:6379\u0026gt; GET greeting \u0026#34;Hello world!\u0026#34;       2. Redis Datatypes Official Documentation: Redis Datatypes\n   Strings\n  Lists\n  Sets\n  Sorted sets\n  Hashes\n  Bitmaps and HyperLogLogs\n   2.1. Lists 2.1.1. LPUSH Insert all the specified values at the head of the list stored at key. If key does not exist, it is created as empty list before performing the push operations.\n  2.1.2. LRANGE Returns the specified elements of the list stored at key. The offsets start and stop are zero-based indexes, with 0 being the first element of the list (the head of the list), 1 being the next element and so on.\n  2.1.3. RPUSH Insert all the specified values at the tail of the list stored at key. If key does not exist, it is created as empty list before performing the push operation.\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 127.0.0.1:6379\u0026gt; LPUSH people \u0026#34;arafat\u0026#34; (integer) 1 127.0.0.1:6379\u0026gt; LPUSH people \u0026#34;Jen\u0026#34; (integer) 2 127.0.0.1:6379\u0026gt; LPUSH people \u0026#34;Tom\u0026#34; (integer) 3 127.0.0.1:6379\u0026gt; LRANGE people 0 -1 1) \u0026#34;Tom\u0026#34; 2) \u0026#34;Jen\u0026#34; 3) \u0026#34;arafat\u0026#34; 127.0.0.1:6379\u0026gt; LRANGE people 1 2 1) \u0026#34;Jen\u0026#34; 2) \u0026#34;arafat\u0026#34; 127.0.0.1:6379\u0026gt; RPUSH people \u0026#34;Harry\u0026#34; (integer) 4 127.0.0.1:6379\u0026gt; LRANGE people 0 -1 1) \u0026#34;Tom\u0026#34; 2) \u0026#34;Jen\u0026#34; 3) \u0026#34;arafat\u0026#34; 4) \u0026#34;Harry\u0026#34;     2.1.4. LPOP Removes and returns the first element of the list stored at key.\n  2.1.5. RPOP Removes and returns the last element of the list stored at key.\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 127.0.0.1:6379\u0026gt; LRANGE people 0 -1 1) \u0026#34;Tom\u0026#34; 2) \u0026#34;Jen\u0026#34; 3) \u0026#34;arafat\u0026#34; 127.0.0.1:6379\u0026gt; LPOP people \u0026#34;Tom\u0026#34; 127.0.0.1:6379\u0026gt; LRANGE people 0 -1 1) \u0026#34;Jen\u0026#34; 2) \u0026#34;arafat\u0026#34; 3) \u0026#34;Harry\u0026#34; 127.0.0.1:6379\u0026gt; RPOP people \u0026#34;Harry\u0026#34; 127.0.0.1:6379\u0026gt; LRANGE people 0 -1 1) \u0026#34;Jen\u0026#34; 2) \u0026#34;arafat\u0026#34;     2.1.6. LINSERT Inserts element in the list stored at key either before or after the reference value pivot.\n When key does not exist, it is considered an empty list and no operation is performed.\n 1 2 3 4 5 6 7 8 9 127.0.0.1:6379\u0026gt; LRANGE people 0 -1 1) \u0026#34;Jen\u0026#34; 2) \u0026#34;arafat\u0026#34; 127.0.0.1:6379\u0026gt; LINSERT people BEFORE \u0026#34;arafat\u0026#34; \u0026#34;Tom\u0026#34; (integer) 3 127.0.0.1:6379\u0026gt; LRANGE people 0 -1 1) \u0026#34;Jen\u0026#34; 2) \u0026#34;Tom\u0026#34; 3) \u0026#34;arafat\u0026#34;      2.2. Sets 2.2.1. SADD Add the specified members to the set stored at key. Specified members that are already a member of this set are ignored. If key does not exist, a new set is created before adding the specified members.\n  2.2.2. SMEMBERS Returns all the members of the set value stored at key.\n  2.2.3. SISMEMBER Returns if member is a member of the set stored at key.\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 127.0.0.1:6379\u0026gt; SADD cars \u0026#34;Ford\u0026#34; (integer) 1 127.0.0.1:6379\u0026gt; SADD cars \u0026#34;Honda\u0026#34; (integer) 1 127.0.0.1:6379\u0026gt; SADD cars \u0026#34;BMW\u0026#34; (integer) 1 127.0.0.1:6379\u0026gt; SMEMBERS cars 1) \u0026#34;Ford\u0026#34; 2) \u0026#34;BMW\u0026#34; 3) \u0026#34;Honda\u0026#34; 127.0.0.1:6379\u0026gt; SISMEMBER cars \u0026#34;Ford\u0026#34; (integer) 1 127.0.0.1:6379\u0026gt; SISMEMBER cars \u0026#34;Chevy\u0026#34; (integer) 0     2.2.4. SCARD Returns the set cardinality (number of elements) of the set stored at key.\n  2.2.5. SMOVE Move member from the set at source to the set at destination. This operation is atomic. In every given moment the element will appear to be a member of source or destination for other clients.\n  2.2.6. SREM Remove the specified members from the set stored at key. Specified members that are not a member of this set are ignored. If key does not exist, it is treated as an empty set and this command returns 0.\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 127.0.0.1:6379\u0026gt; SMEMBERS cars 1) \u0026#34;Ford\u0026#34; 2) \u0026#34;BMW\u0026#34; 3) \u0026#34;Honda\u0026#34; 127.0.0.1:6379\u0026gt; SCARD cars (integer) 3 127.0.0.1:6379\u0026gt; SMOVE cars mycars \u0026#34;Ford\u0026#34; (integer) 1 127.0.0.1:6379\u0026gt; SMEMBERS cars 1) \u0026#34;BMW\u0026#34; 2) \u0026#34;Honda\u0026#34; 127.0.0.1:6379\u0026gt; SMEMBERS mycars 1) \u0026#34;Ford\u0026#34; 127.0.0.1:6379\u0026gt; SREM cars \u0026#34;BMW\u0026#34; (integer) 1 127.0.0.1:6379\u0026gt; SMEMBERS cars 1) \u0026#34;Honda\u0026#34; 127.0.0.1:6379\u0026gt; FLUSHALL OK      2.3. Sorted Sets 2.3.1. ZADD Adds all the specified members with the specified scores to the sorted set stored at key. It is possible to specify multiple score / member pairs. If a specified member is already a member of the sorted set, the score is updated and the element reinserted at the right position to ensure the correct ordering.\n  2.3.2. ZRANK Returns the rank of member in the sorted set stored at key, with the scores ordered from low to high. The rank (or index) is 0-based, which means that the member with the lowest score has rank 0.\n  2.3.3. ZRANGE Returns the specified range of elements in the sorted set stored at key.\n  2.3.4. ZINCRBY Increments the score of member in the sorted set stored at key by increment. If member does not exist in the sorted set, it is added with increment as its score (as if its previous score was 0.0). If key does not exist, a new sorted set with the specified member as its sole member is created.\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 127.0.0.1:6379\u0026gt; ZADD users 1981 \u0026#34;Arafat Hasan\u0026#34; (integer) 1 127.0.0.1:6379\u0026gt; ZADD users 1975 \u0026#34;John Doe\u0026#34; (integer) 1 127.0.0.1:6379\u0026gt; ZADD users 1990 \u0026#34;Mike Smith\u0026#34; (integer) 1 127.0.0.1:6379\u0026gt; ZADD users 1990 \u0026#34;Kate Rogers\u0026#34; (integer) 1 127.0.0.1:6379\u0026gt; ZRANK users \u0026#34;Mike Smith\u0026#34; (integer) 3 127.0.0.1:6379\u0026gt; ZRANK users \u0026#34;John Doe\u0026#34; (integer) 0 127.0.0.1:6379\u0026gt; ZRANK users \u0026#34;John Do\u0026#34; (nil) 127.0.0.1:6379\u0026gt; ZRANK users \u0026#34;Arafat Hasan\u0026#34; (integer) 1 127.0.0.1:6379\u0026gt; ZRANGE users 0 -1 1) \u0026#34;John Doe\u0026#34; 2) \u0026#34;Arafat Hasan\u0026#34; 3) \u0026#34;Kate Rogers\u0026#34; 4) \u0026#34;Mike Smith\u0026#34; 127.0.0.1:6379\u0026gt; ZINCRBY users 1 \u0026#34;John Doe\u0026#34; \u0026#34;1976\u0026#34; 127.0.0.1:6379\u0026gt; ZINCRBY users 10 \u0026#34;John Doe\u0026#34; \u0026#34;1986\u0026#34; 127.0.0.1:6379\u0026gt; FLUSHALL OK      2.4. Hash 2.4.1. HSET Sets field in the hash stored at key to value. If key does not exist, a new key holding a hash is created. If field already exists in the hash, it is overwritten.\n  2.4.2. HGET Returns the value associated with field in the hash stored at key.\n  2.4.3. HGETALL Returns all fields and values of the hash stored at key. In the returned value, every field name is followed by its value, so the length of the reply is twice the size of the hash.\n 1 2 3 4 5 6 7 8 9 10 11 127.0.0.1:6379\u0026gt; HSET user:arafat name \u0026#34;Arafat Hasan\u0026#34; (integer) 1 127.0.0.1:6379\u0026gt; HSET user:arafat email \u0026#34;arafat@example.com\u0026#34; (integer) 1 127.0.0.1:6379\u0026gt; HGET user:arafat email \u0026#34;arafat@example.com\u0026#34; 127.0.0.1:6379\u0026gt; HGETALL user:arafat 1) \u0026#34;name\u0026#34; 2) \u0026#34;Arafat Hasan\u0026#34; 3) \u0026#34;email\u0026#34; 4) \u0026#34;arafat@example.com\u0026#34;     2.4.4. HMSET Sets the specified fields to their respective values in the hash stored at key.\n  2.4.5. HKEYS Returns all field names in the hash stored at key.\n  2.4.6. HVALS Returns all values in the hash stored at key.\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 127.0.0.1:6379\u0026gt; HMSET user:john name \u0026#34;John Doe\u0026#34; email \u0026#34;doe@example.com\u0026#34; age \u0026#34;25\u0026#34; OK 127.0.0.1:6379\u0026gt; HGETALL user:john 1) \u0026#34;name\u0026#34; 2) \u0026#34;John Doe\u0026#34; 3) \u0026#34;email\u0026#34; 4) \u0026#34;doe@example.com\u0026#34; 5) \u0026#34;age\u0026#34; 6) \u0026#34;25\u0026#34; 127.0.0.1:6379\u0026gt; HKEYS user:john 1) \u0026#34;name\u0026#34; 2) \u0026#34;email\u0026#34; 3) \u0026#34;age\u0026#34; 127.0.0.1:6379\u0026gt; HVALS user:john 1) \u0026#34;John Doe\u0026#34; 2) \u0026#34;doe@example.com\u0026#34; 3) \u0026#34;25\u0026#34;     2.4.7. HINCRBY Increments the number stored at field in the hash stored at key by increment.\n  2.4.8. HDEL Removes the specified fields from the hash stored at key.\n  2.4.9. HLEN Returns the number of fields contained in the hash stored at key.\n 1 2 3 4 5 6 7 8 9 10 11 127.0.0.1:6379\u0026gt; HINCRBY user:john age 1 (integer) 26 127.0.0.1:6379\u0026gt; HDEL user:john age (integer) 1 127.0.0.1:6379\u0026gt; HGETALL user:john 1) \u0026#34;name\u0026#34; 2) \u0026#34;John Doe\u0026#34; 3) \u0026#34;email\u0026#34; 4) \u0026#34;doe@example.com\u0026#34; 127.0.0.1:6379\u0026gt; HLEN user:john (integer) 2        3. Redis Persistence Official Documentation: Redis Persistence\n   ","permalink":"https://arafat-hasan.github.io/en/post/redis-hello-world/","tags":["redis","note"],"title":"Redis: Hello World!"},{"categories":["professional writings"],"contents":" This writing is actually a draft note made for myself, so that I myself don’t forget what I had learned. But I think this note will be helpful for those who want to learn Redis.\n 1. Introduction to Redis Redis is an acronym for Remote dictionary server. It’s an open source, in-memory and persistent key-value database / store which stores data as key-value pairs and also doubles up as a message broker. Redis supports a wide array of data structures including sets, lists, hashes, strings, HyperLogLogs and so many more.\n What is a key-value pair?\n A key-value pair is a set or pair of two linked items. Consider the following:\n car = Mercedes\n In this case, car is the key and Mercedes is the value. In a Redis database, this information can be written using the syntax: SET \u0026#34;key1\u0026#34; \u0026#34;value1\u0026#34;. Our example will translate to: SET \u0026#34;car\u0026#34; \u0026#34;Mercedes\u0026#34;.\n 1.1. Benefits of using Redis   Unlike relational databases like MySQL, Redis is a NoSQL database that stores data as a key value pair. This makes it simple and flexible as there’s no need of creating any tables , columns and rows which are associated with relational databases. Feeding data to Redis is simple and straightforward.\n  One of the apparent uses of Redis is its use as a caching system. While it does so, it also offers persistence to data being written on it.\n  The in-memory architecture of Redis makes it super-fast in storage and retrieval of data.\n  The redis cache system is quite robust and has the capacity of withstanding failures and interruptions.\n  Redis ships with a Master-Slave replication feature. When changes are made to the master node, they are automatically replicated on the slave nodes to ensure high availability.\n  Redis has the ability to store large key \u0026amp; value pairs of up to 512 MB.\n  Given its small footprint, Redis can be installed in IoT devices such as Raspberry Pi and Arduino to support IoT apps.\n  Redis is a cross-platform database and caching system which can be installed in Windows , mac and Linux.\n      2. Installation 2.1. Install Redis on CentOS 8 2.1.1. Update system repositories Login to your CentOS 8 / RHEL 8 system and update system packages and repositories using the command:\n $ sudo dnf update -y    2.1.2. Install Redis with dnf Redis version 5.0.x is now included in CentOS 8 AppStream repository and installing it is a walk in the park. Simply run the command:\n $ sudo dnf install redis -y   সংস্থাপন সম্পন্ন হলে নিচের কমান্ডটি চালিয়ে রেডিসের সংস্করণটি যাচাই করতে পারবেন:\n Once installed, you can verify the version of Redis installed by running the command:\n 1 2 [arafat@server ~]$ rpm -q redis redis-5.0.3-2.module_el8.2.0+318+3d7e67ea.x86_64    আউটপুট থেকে, এটি স্পষ্ট যে আমরা রেডিস সংস্করণ ৫.০.৩ সংস্থাপন করেছি। রেডিসের সংস্করণ, আর্কিটেকচার, লাইসেন্স এবং সংক্ষিপ্ত বিবরণ পেতে এই কমান্ডটি চালান:\n From the output , it is clear that we have installed Redis version 5.0.3. To retrieve more information about Redis such as the version, architecture, license and a brief description, run the command:\n $ rpm -qi redis   রেডিস চালু করতে সিস্টেম কনট্রোল দিয়ে রেডিস চালু করতে হবে।\n To start Redis:\n $ sudo systemctl start redis   প্রতি সিস্টেম বুটে স্বয়ংক্রিয়ভাবে রেডিস চালু করতে চাইলে সিস্টেম কনট্রোলে রেডিস সক্ষম করতে হবে:\n If you want to automatically start Redis in each system boot, you need to enable Redis:\n $ sudo systemctl enable redis   রেডিসের অবস্থা:\n To see status:\n $ sudo systemctl status redis   ডিফল্টভাবে, রেডিস ৬৩৭৯ পোর্টে চালিত হয়। netstat আদেশ চালিয়ে এটি নিশ্চিত হওয়া যাবে:\n By default, Redis runs on port 6379. This can be confirmed by running the netstat command:\n $ sudo netstat -pnltu | grep redis       3. Configure Redis 3.1. Allow Remote Access The default installation only allows connections from localhost or Redis server and blocks any external connections. We are going to configure Redis for remote connection from a client machine.\n Access the configuration file as shown:\n $ sudo vim /etc/redis.conf   Locate the bind parameter and replace 127.0.0.1 with 0.0.0.0\n bind 0.0.0.0   Save and close the configuration file. For the changes to come into effect, restart Redis.\n $ sudo systemctl restart redis   To log in to Redis shell, run the command:\n $ redis-cli   Try to ping redis server. You should get a ‘PONG’ response as shown.\n [arafat@server ~]$ redis-cli 127.0.0.1:6379\u0026gt; ping PONG 127.0.0.1:6379\u0026gt;    3.2. Securing Redis Server Our Redis setup allows anyone to access the shell and databases without authentication which poses a grave security risk. To set a password, head back to the configuration file /etc/redis.conf\n Locate and uncomment the requirepass parameter and specify a strong password.\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ================================== SECURITY =================================== # Require clients to issue AUTH \u0026lt;PASSWORD\u0026gt; before processing any other # commands. This might be useful in environments in which you do not trust # others with access to the host running redis-server. # # This should stay commented out for backward compatibility and because most # people do not need auth (e.g. they run their own servers). # # Warning: since Redis is pretty fast an outside user can try up to # 150k passwords per second against a good box. This means that you should # use a very strong password otherwise it will be very easy to break. # # requirepass foobared    Restart Redis and head back to the server.\n $ sudo systemctl restart redis   If you attempt to run any command before authenticating, the error shown below will be displayed\n [arafat@server ~]$ redis-cli 127.0.0.1:6379\u0026gt; ping (error) NOAUTH Authentication required. 127.0.0.1:6379\u0026gt;   To authenticate, type ‘auth’ followed by the password set.\n auth \u0026#39;PASSWORD\u0026#39;   Thereafter, you can continue running your commands.\n 1 2 3 4 5 6 [arafat@server ~]$ redis-cli 127.0.0.1:6379\u0026gt; auth \u0026#39;PASSWORD\u0026#39; OK 127.0.0.1:6379\u0026gt; ping PONG 127.0.0.1:6379\u0026gt;    To come out from redis-cli, type exit\n 3.2.1. Configuring the Firewall for Redis Lastly, we need to configure the firewall to allow remote connections to the Redis server. To do this, we need to open the redis port which is 6379.\n So, run the commands below.\n 1 2 $ sudo firewall-cmd --add-port=6379/tcp --permanent $ sudo firewall-cmd --reload    To access Redis remotely, use the syntax below.\n $ redis-cli -h REDIS_IP_ADDRESS   Next authenticate and hit ‘ENTER’\n The IP address of our Redis server is 192.168.1.5 The command from another client PC will be\n $ redis-cli -h 192.168.1.5   Next, provide the password and hit ‘ENTER’\n auth \u0026#39;PASSWORD\u0026#39;     3.3. How to perform Redis Benchmark Redis comes with a built-in tool known as redis-benchmark that gives insights on the system’s performance statistics such as data transfer rate, throughput and latency to mention a few.\n Some of the command options you can use with Redis include\n   -n:\tThis defines the number of requests to be made. The default is 100000\n  -c:\tDefines the number of parallel connections to be simulated. By default, this value is 50\n  -p:\tThis is the Redis port which by default is 6379\n  -h:\tUsed to define the host. By default, this value is set to localhost (127.0.0.1)\n  -a:\tUsed to prompt for a password if the server needs authentication\n  -q:\tStands for quiet mode. Displays the average requests made per second\n  -t:\tUsed to run a combination of tests\n  -P:\tUsed for pipelining for enhanced performance.\n  -d: Specifies the data size in bytes for GET and SET values. By default, this is set to 3 bytes\n   Examples:\n To confirm the average no. of requests that your Redis server can handle run the command:\n $ redis-benchmark -q      ","permalink":"https://arafat-hasan.github.io/en/post/redis-intro/","tags":["redis","note"],"title":"Redis Introduction and Installation"},{"categories":["professional writings"],"contents":" This writing is actually a draft note made for me so that I myself don’t forget what I have learned. For that, I think this note will be helpful for those who want to learn new Postgres.\n 1. The Shallow Sea 1.1. PRIMARY KEY The PRIMARY KEY of a table is a combination of NOT NULL and UNIQUE constraint. Here we will see how to delete and add a primary key.\n At first, we check the table description, and we have found that the id column is a PRIMARY KEY. Use command \\d person;.\n 1 2 3 4 5 6 7 8 9 10 11 12  Table \u0026#34;public.person\u0026#34; Column | Type | Collation | Nullable | Default ------------------+------------------------+-----------+----------+------------------------------------ id | bigint | | not null | nextval(\u0026#39;person_id_seq\u0026#39;::regclass) first_name | character varying(50) | | not null | last_name | character varying(50) | | not null | email | character varying(150) | | | gender | character varying(7) | | not null | date_of_birth | date | | not null | country_of_birth | character varying(50) | | not null | Indexes: \u0026#34;person_pkey\u0026#34; PRIMARY KEY, btree (id)    Now we will try to add a duplicate value to the table.\n 1 2 3 4 5 6 7 8 9 test=# SELECT * FROM person WHERE id=1; id | first_name | last_name | email | gender | date_of_birth | country_of_birth ----+------------+-----------+---------------------------+--------+---------------+------------------ 1 | Ronda | Skermer | rskermer0@arstechnica.com | Female | 1993-06-30 | Argentina (1 row) test=# INSERT INTO person (id, first_name, last_name, email, gender, date_of_birth, country_of_birth) VALUES (1, \u0026#39;Ronda\u0026#39;, \u0026#39;Skermer\u0026#39;, \u0026#39;rskermer0@arstechnica.com\u0026#39;, \u0026#39;Female\u0026#39;, \u0026#39;1993-06-30\u0026#39;, \u0026#39;Argentina\u0026#39;); ERROR: duplicate key value violates unique constraint \u0026#34;person_pkey\u0026#34; DETAIL: Key (id)=(1) already exists.    Insertion value is failed as the id column is primary, and it says duplicate key value violates unique constraint. Now we will drop the primary key constraint of the id column and will again try to insert duplicate data into the table.\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 test=# ALTER TABLE person DROP CONSTRAINT person_pkey; ALTER TABLE test=# \\d person; Table \u0026#34;public.person\u0026#34; Column | Type | Collation | Nullable | Default ------------------+------------------------+-----------+----------+------------------------------------ id | bigint | | not null | nextval(\u0026#39;person_id_seq\u0026#39;::regclass) first_name | character varying(50) | | not null | last_name | character varying(50) | | not null | email | character varying(150) | | | gender | character varying(7) | | not null | date_of_birth | date | | not null | country_of_birth | character varying(50) | | not null | test=# INSERT INTO person (id, first_name, last_name, email, gender, date_of_birth, country_of_birth) VALUES (1, \u0026#39;Ronda\u0026#39;, \u0026#39;Skermer\u0026#39;, \u0026#39;rskermer0@arstechnica.com\u0026#39;, \u0026#39;Female\u0026#39;, \u0026#39;1993-06-30\u0026#39;, \u0026#39;Argentina\u0026#39;); INSERT 0 1 test=# SELECT * FROM person WHERE id=1; id | first_name | last_name | email | gender | date_of_birth | country_of_birth ----+------------+-----------+---------------------------+--------+---------------+------------------ 1 | Ronda | Skermer | rskermer0@arstechnica.com | Female | 1993-06-30 | Argentina 1 | Ronda | Skermer | rskermer0@arstechnica.com | Female | 1993-06-30 | Argentina (2 rows)    Here, as we can see that, after dropping the primary key constrains, we can insert a duplicate row in the table.\n Now we will try to add primary key constraint in the id column.\n 1 2 3 test=# ALTER TABLE person ADD PRIMARY KEY(id); ERROR: could not create unique index \u0026#34;person_pkey\u0026#34; DETAIL: Key (id)=(1) is duplicated.    But we had failed, as there is two-row containing the same id. Now delete one of the duplicate ids and again try to add a primary key.\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 test=# DELETE FROM person WHERE id=1; DELETE 2 test=# SELECT * FROM person WHERE id=1; id | first_name | last_name | email | gender | date_of_birth | country_of_birth ----+------------+-----------+-------+--------+---------------+------------------ (0 rows) test=# INSERT INTO person (id, first_name, last_name, email, gender, date_of_birth, country_of_birth) VALUES (1, \u0026#39;Ronda\u0026#39;, \u0026#39;Skermer\u0026#39;, \u0026#39;rskermer0@arstechnica.com\u0026#39;, \u0026#39;Female\u0026#39;, \u0026#39;1993-06-30\u0026#39;, \u0026#39;Argentina\u0026#39;); INSERT 0 1 test=# SELECT * FROM person WHERE id=1; id | first_name | last_name | email | gender | date_of_birth | country_of_birth ----+------------+-----------+---------------------------+--------+---------------+------------------ 1 | Ronda | Skermer | rskermer0@arstechnica.com | Female | 1993-06-30 | Argentina (1 row) test=# ALTER TABLE person ADD PRIMARY KEY(id); ALTER TABLE test=# \\d person; Table \u0026#34;public.person\u0026#34; Column | Type | Collation | Nullable | Default ------------------+------------------------+-----------+----------+------------------------------------ id | bigint | | not null | nextval(\u0026#39;person_id_seq\u0026#39;::regclass) first_name | character varying(50) | | not null | last_name | character varying(50) | | not null | email | character varying(150) | | | gender | character varying(7) | | not null | date_of_birth | date | | not null | country_of_birth | character varying(50) | | not null | Indexes: \u0026#34;person_pkey\u0026#34; PRIMARY KEY, btree (id) test=#    Our primary key constraint in the id column is back again.\n  1.2. CONSTRAINTS 1.2.1. UNIQUE constraint The PostgreSQL UNIQUE constraint ensures that the uniqueness of the values entered into a column or a field of a table.\n The UNIQUE constraint in PostgreSQL can be applied as a column constraint or a group of column constraint or a table constraint.\n The UNIQUE constraint in PostgreSQL is violated when more than one row for a column or combination of columns which have been used as a unique constraint in a table. Two NULL values for a column in different rows are different, and it does not violate the uniqueness of the UNIQUE constraint.\n When a UNIQUE constraint is adding, an index on a column or group of columns creates automatically.\n We are going to add a UNIQUE CONSTRAINT in the email field, and after that, we will delete the constraint of the field.\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 test=# ALTER TABLE person ADD CONSTRAINT unique_email_addr UNIQUE(email); ALTER TABLE test=# \\d person; Table \u0026#34;public.person\u0026#34; Column | Type | Collation | Nullable | Default ------------------+------------------------+-----------+----------+------------------------------------ id | bigint | | not null | nextval(\u0026#39;person_id_seq\u0026#39;::regclass) first_name | character varying(50) | | not null | last_name | character varying(50) | | not null | email | character varying(150) | | | gender | character varying(7) | | not null | date_of_birth | date | | not null | country_of_birth | character varying(50) | | not null | Indexes: \u0026#34;person_pkey\u0026#34; PRIMARY KEY, btree (id) \u0026#34;unique_email_addr\u0026#34; UNIQUE CONSTRAINT, btree (email) test=# ALTER TABLE person DROP CONSTRAINT unique_email_addr; ALTER TABLE test=# \\d person; Table \u0026#34;public.person\u0026#34; Column | Type | Collation | Nullable | Default ------------------+------------------------+-----------+----------+------------------------------------ id | bigint | | not null | nextval(\u0026#39;person_id_seq\u0026#39;::regclass) first_name | character varying(50) | | not null | last_name | character varying(50) | | not null | email | character varying(150) | | | gender | character varying(7) | | not null | date_of_birth | date | | not null | country_of_birth | character varying(50) | | not null | Indexes: \u0026#34;person_pkey\u0026#34; PRIMARY KEY, btree (id)    Again we will add unique constraints in the email field, but without mentioning the name of our constraint, the name of the constraint will be set by Postgres itself automatically.\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 test=# ALTER TABLE person ADD UNIQUE(email); ALTER TABLE test=# \\d person; Table \u0026#34;public.person\u0026#34; Column | Type | Collation | Nullable | Default ------------------+------------------------+-----------+----------+------------------------------------ id | bigint | | not null | nextval(\u0026#39;person_id_seq\u0026#39;::regclass) first_name | character varying(50) | | not null | last_name | character varying(50) | | not null | email | character varying(150) | | | gender | character varying(7) | | not null | date_of_birth | date | | not null | country_of_birth | character varying(50) | | not null | Indexes: \u0026#34;person_pkey\u0026#34; PRIMARY KEY, btree (id) \u0026#34;person_email_key\u0026#34; UNIQUE CONSTRAINT, btree (email)     1.2.2. CHECK Constraint The PostgreSQL CHECK constraint controls the value of a column(s) being inserted.\n PostgreSQL provides the CHECK constraint, which allows the user to define a condition that a value entered into a table, has to satisfy before it can be accepted. The CHECK constraint consists of the keyword CHECK, followed by parenthesized conditions. The attempt will be rejected when update or insert column values that will make the condition false.\n The CHECK constraint in PostgreSQL can be defined as a separate name.\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 test=# ALTER TABLE person ADD CONSTRAINT gender_constraint CHECK (gender = \u0026#39;Female\u0026#39; OR gender = \u0026#39;Male\u0026#39;); ALTER TABLE test=# \\d person; Table \u0026#34;public.person\u0026#34; Column | Type | Collation | Nullable | Default ------------------+------------------------+-----------+----------+------------------------------------ id | bigint | | not null | nextval(\u0026#39;person_id_seq\u0026#39;::regclass) first_name | character varying(50) | | not null | last_name | character varying(50) | | not null | email | character varying(150) | | | gender | character varying(7) | | not null | date_of_birth | date | | not null | country_of_birth | character varying(50) | | not null | Indexes: \u0026#34;person_pkey\u0026#34; PRIMARY KEY, btree (id) \u0026#34;person_email_key\u0026#34; UNIQUE CONSTRAINT, btree (email) Check constraints: \u0026#34;gender_constraint\u0026#34; CHECK (gender::text = \u0026#39;Female\u0026#39;::text OR gender::text = \u0026#39;Male\u0026#39;::text)      1.3. DELETE Following is the usage of the PostgreSQL DELETE command to delete data of a PostgreSQL table.\n 1 DELETE FROM table_name ;    Where table_name is the associated table, executing this command will delete all the rows of the associated table.\n 1 DELETE FROM table_name WHERE condition;    If we don’t want to delete all of the rows of a table, but some specific rows which match the \u0026#34;condition\u0026#34;, execute the above.\n First, try to delete all records from a table.\n 1 2 3 4 5 6 test=# DELETE FROM person; DELETE 1000 test=# SELECT * FROM person; id | first_name | last_name | email | gender | date_of_birth | country_of_birth ----+------------+-----------+-------+--------+---------------+------------------ (0 rows)    There is no record in the person table now. For our learning purpose, retrieve data from the SQL file for the table again.\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 test=# \\i /path/to/person.sql psql:/path/to/person.sql:9: ERROR: relation \u0026#34;person\u0026#34; already exists INSERT 0 1 --More-- test=# \\d person; Table \u0026#34;public.person\u0026#34; Column | Type | Collation | Nullable | Default ------------------+------------------------+-----------+----------+------------------------------------ id | bigint | | not null | nextval(\u0026#39;person_id_seq\u0026#39;::regclass) first_name | character varying(50) | | not null | last_name | character varying(50) | | not null | email | character varying(150) | | | gender | character varying(7) | | not null | date_of_birth | date | | not null | country_of_birth | character varying(50) | | not null | Indexes: \u0026#34;person_pkey\u0026#34; PRIMARY KEY, btree (id) \u0026#34;person_email_key\u0026#34; UNIQUE CONSTRAINT, btree (email) Check constraints: \u0026#34;gender_constraint\u0026#34; CHECK (gender::text = \u0026#39;Female\u0026#39;::text OR gender::text = \u0026#39;Male\u0026#39;::text) test=# SELECT * FROM person LIMIT 10; id | first_name | last_name | email | gender | date_of_birth | country_of_birth ------+------------+---------------+--------------------------------+--------+---------------+------------------ 1002 | Ronda | Skermer | rskermer0@arstechnica.com | Female | 1993-06-30 | Argentina 1003 | Hamid | Abbett | habbett1@cbc.ca | Male | 1995-08-31 | Ethiopia 1004 | Francis | Nickerson | fnickerson2@mac.com | Male | 1998-03-16 | Portugal 1005 | Erminie | M\u0026#39;Quharg | emquharg3@e-recht24.de | Female | 1999-03-13 | Mozambique 1006 | Teodoro | Trimmill | | Male | 1982-04-30 | China 1007 | Reilly | Amesbury | ramesbury5@businessinsider.com | Male | 1990-12-31 | China 1008 | West | Elphey | | Male | 2004-03-29 | Indonesia 1009 | Letta | Caurah | lcaurah7@yale.edu | Female | 1994-09-09 | Indonesia 1010 | Elset | Agass | eagass8@rambler.ru | Female | 2004-06-26 | China 1011 | Aurore | Drillingcourt | adrillingcourt9@cnet.com | Female | 1977-10-19 | China (10 rows)    Now try to delete a specific row or rows with the matching condition.\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 test=# DELETE FROM person WHERE id = 1002; DELETE 1 test=# SELECT * FROM person LIMIT 10; id | first_name | last_name | email | gender | date_of_birth | country_of_birth ------+------------+---------------+--------------------------------+--------+---------------+------------------ 1003 | Hamid | Abbett | habbett1@cbc.ca | Male | 1995-08-31 | Ethiopia 1004 | Francis | Nickerson | fnickerson2@mac.com | Male | 1998-03-16 | Portugal 1005 | Erminie | M\u0026#39;Quharg | emquharg3@e-recht24.de | Female | 1999-03-13 | Mozambique 1006 | Teodoro | Trimmill | | Male | 1982-04-30 | China 1007 | Reilly | Amesbury | ramesbury5@businessinsider.com | Male | 1990-12-31 | China 1008 | West | Elphey | | Male | 2004-03-29 | Indonesia 1009 | Letta | Caurah | lcaurah7@yale.edu | Female | 1994-09-09 | Indonesia 1010 | Elset | Agass | eagass8@rambler.ru | Female | 2004-06-26 | China 1011 | Aurore | Drillingcourt | adrillingcourt9@cnet.com | Female | 1977-10-19 | China 1012 | Ilse | Goldman | igoldmana@ihg.com | Female | 2001-07-31 | Mongolia (10 rows) test=# DELETE FROM person WHERE gender=\u0026#39;Female\u0026#39; AND country_of_birth=\u0026#39;China\u0026#39;; DELETE 94 test=# SELECT * FROM person WHERE gender=\u0026#39;Female\u0026#39; AND country_of_birth=\u0026#39;China\u0026#39;; id | first_name | last_name | email | gender | date_of_birth | country_of_birth ----+------------+-----------+-------+--------+---------------+------------------ (0 rows)    For our learning purpose, now we will delete every record from the person table and restore it from our SQL file.\n 1 2 3 4 5 6 test=# DELETE FROM person; DELETE 905 test=# \\i /path/to/person.sql psql:/path/to/person.sql:9: ERROR: relation \u0026#34;person\u0026#34; already exists INSERT 0 1 --More--     1.4. UPDATE UPDATE command is used to modify existing data of a table.\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 test=# SELECT * FROM person; id | first_name | last_name | email | gender | date_of_birth | country_of_birth ------+----------------+---------------------+-----------------------------------------+--------+---------------+---------------------------------- 2002 | Ronda | Skermer | rskermer0@arstechnica.com | Female | 1993-06-30 | Argentina 2003 | Hamid | Abbett | habbett1@cbc.ca | Male | 1995-08-31 | Ethiopia 2004 | Francis | Nickerson | fnickerson2@mac.com | Male | 1998-03-16 | Portugal 2005 | Erminie | M\u0026#39;Quharg | emquharg3@e-recht24.de | Female | 1999-03-13 | Mozambique 2006 | Teodoro | Trimmill | | Male | 1982-04-30 | China 2007 | Reilly | Amesbury | ramesbury5@businessinsider.com | Male | 1990-12-31 | China 2008 | West | Elphey | | Male | 2004-03-29 | Indonesia --More-- test=# UPDATE person SET email = \u0026#39;teodoro@gmail.com\u0026#39; WHERE id = 2006; UPDATE 1 test=# SELECT * FROM person WHERE id = 2006; id | first_name | last_name | email | gender | date_of_birth | country_of_birth ------+------------+-----------+-------------------+--------+---------------+------------------ 2006 | Teodoro | Trimmill | teodoro@gmail.com | Male | 1982-04-30 | China (1 row) test=# UPDATE person SET last_name = \u0026#39;Trimmil\u0026#39;, email = \u0026#39;teodoro@hotmail.com\u0026#39; WHERE id = 2006; UPDATE 1 test=# SELECT * FROM person WHERE id = 2006; id | first_name | last_name | email | gender | date_of_birth | country_of_birth ------+------------+-----------+---------------------+--------+---------------+------------------ 2006 | Teodoro | Trimmil | teodoro@hotmail.com | Male | 1982-04-30 | China (1 row)     1.5. ON CONFLICT 1.5.1. DO NOTHING This means do nothing if the row already exists in the table. It handles duplicate key errors.\n First, we try to enter the duplicate record.\n Command\n 1 2 INSERT INTO person (id, first_name, last_name, gender, email, date_of_birth, country_of_birth) VALUES (2002, \u0026#39;Ronda\u0026#39;, \u0026#39;Dante\u0026#39;, \u0026#39;Male\u0026#39;, \u0026#39;dante@hotmaill.com\u0026#39;, DATE \u0026#39;1980-03-12\u0026#39;, \u0026#39;Sri Lanka\u0026#39;);    As expected, an ERROR message is thrown.\n Output\n 1 2 ERROR: duplicate key value violates unique constraint \u0026#34;person_pkey\u0026#34; DETAIL: Key (id)=(2002) already exists.    Now we try to enter the duplicate record with ON CONFLICT(id) DO NOTHING and handle the error.\n Command\n 1 2 3 INSERT INTO person (id, first_name, last_name, gender, email, date_of_birth, country_of_birth) VALUES (2002, \u0026#39;Ronda\u0026#39;, \u0026#39;Dante\u0026#39;, \u0026#39;Male\u0026#39;, \u0026#39;dante@hotmaill.com\u0026#39;, DATE \u0026#39;1980-03-12\u0026#39;, \u0026#39;Sri Lanka\u0026#39;) ON CONFLICT(id) DO NOTHING;    The output message is saying 0 0, which means no insert operation is held.\n Output\n 1 INSERT 0 0     1.5.2. DO UPDATE SET This update some fields in the table.\n We will update this record in a way that conflicts with it.\n 1 2 3 4 5 test=# SELECT * FROM person WHERE id = 2002; id | first_name | last_name | email | gender | date_of_birth | country_of_birth ------+------------+-----------+---------------------------+--------+---------------+------------------ 2002 | Ronda | Skermer | rskermer0@arstechnica.com | Female | 1993-06-30 | Argentina (1 row)    Here EXCLUDED refers to the new conflicted record which is trying to be inserted.\n Command\n 1 2 3 INSERT INTO person (id, first_name, last_name, gender, email, date_of_birth, country_of_birth) VALUES (2002, \u0026#39;Rudi\u0026#39;, \u0026#39;Donte\u0026#39;, \u0026#39;Male\u0026#39;, \u0026#39;donte@hotmaill.com\u0026#39;, DATE \u0026#39;1980-03-12\u0026#39;, \u0026#39;Sri Lanka\u0026#39;) ON CONFLICT(id) DO UPDATE SET first_name=EXCLUDED.first_name, last_name=EXCLUDED.last_name, email=EXCLUDED.email;    Output\n INSERT 0 1   Despite the conflict, the updated record is:\n 1 2 3 4 5 test=# SELECT * FROM person WHERE id = 2002; id | first_name | last_name | email | gender | date_of_birth | country_of_birth ------+------------+-----------+--------------------+--------+---------------+------------------ 2002 | Rudi | Donte | donte@hotmaill.com | Female | 1993-06-30 | Argentina (1 row)      1.6. Foreign Keys, Joins and Relationships \n Adding relations between tables We will now drop the previous tables and create new ones with relations.\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 test=# \\dt List of relations Schema | Name | Type | Owner --------+--------+-------+-------------- public | car | table | arafat_hasan public | person | table | arafat_hasan (2 rows) test=# DROP TABLE car; DROP TABLE test=# DROP TABLE person; DROP TABLE test=# \\dt Did not find any relations. test=# \\i /path/to/new/file/car-person.sql CREATE TABLE CREATE TABLE INSERT 0 1 INSERT 0 1 INSERT 0 1 INSERT 0 1 INSERT 0 1 INSERT 0 1 INSERT 0 1 INSERT 0 1 INSERT 0 1 INSERT 0 1 INSERT 0 1 INSERT 0 1 INSERT 0 1 INSERT 0 1 INSERT 0 1 INSERT 0 1 INSERT 0 1 test=# \\dt List of relations Schema | Name | Type | Owner --------+--------+-------+-------------- public | car | table | arafat_hasan public | person | table | arafat_hasan (2 rows)    Our new SQL file, which is named car-person.sql is in bellow:\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 CREATE TABLE car ( id BIGSERIAL NOT NULL PRIMARY KEY, make VARCHAR(100) NOT NULL, model VARCHAR(100) NOT NULL, price NUMERIC(19, 2) NOT NULL ); CREATE TABLE person ( id BIGSERIAL NOT NULL PRIMARY KEY, first_name VARCHAR(50) NOT NULL, last_name VARCHAR(50) NOT NULL, email VARCHAR(150), gender VARCHAR(7) NOT NULL, date_of_birth DATE NOT NULL, country_of_birth VARCHAR(50) NOT NULL, car_id BIGINT REFERENCES car(id), UNIQUE(car_id) ); INSERT INTO car (make, model, price) VALUES (\u0026#39;Daewoo\u0026#39;, \u0026#39;Leganza\u0026#39;, \u0026#39;241058.40\u0026#39;); INSERT INTO car (make, model, price) VALUES (\u0026#39;Mitsubishi\u0026#39;, \u0026#39;Montero\u0026#39;, \u0026#39;269595.21\u0026#39;); INSERT INTO car (make, model, price) VALUES (\u0026#39;Kia\u0026#39;, \u0026#39;Rio\u0026#39;, \u0026#39;245275.16\u0026#39;); INSERT INTO car (make, model, price) VALUES (\u0026#39;Jaguar\u0026#39;, \u0026#39;X-Type\u0026#39;, \u0026#39;41665.96\u0026#39;); INSERT INTO car (make, model, price) VALUES (\u0026#39;Lincoln\u0026#39;, \u0026#39;Mark VIII\u0026#39;, \u0026#39;163843.38\u0026#39;); INSERT INTO car (make, model, price) VALUES (\u0026#39;GMC\u0026#39;, \u0026#39;Rally Wagon 3500\u0026#39;, \u0026#39;231169.05\u0026#39;); INSERT INTO car (make, model, price) VALUES (\u0026#39;Cadillac\u0026#39;, \u0026#39;Escalade ESV\u0026#39;, \u0026#39;279951.34\u0026#39;); INSERT INTO person (first_name, last_name, email, gender, date_of_birth, country_of_birth) VALUES (\u0026#39;Hamid\u0026#39;, \u0026#39;Abbett\u0026#39;, \u0026#39;habbett1@cbc.ca\u0026#39;, \u0026#39;Male\u0026#39;, \u0026#39;1995-08-31\u0026#39;, \u0026#39;Ethiopia\u0026#39;); INSERT INTO person (first_name, last_name, email, gender, date_of_birth, country_of_birth) VALUES (\u0026#39;Francis\u0026#39;, \u0026#39;Nickerson\u0026#39;, \u0026#39;fnickerson2@mac.com\u0026#39;, \u0026#39;Male\u0026#39;, \u0026#39;1998-03-16\u0026#39;, \u0026#39;Portugal\u0026#39;); INSERT INTO person (first_name, last_name, email, gender, date_of_birth, country_of_birth) VALUES (\u0026#39;Erminie\u0026#39;, \u0026#39;M\u0026#39;\u0026#39;Quharg\u0026#39;, \u0026#39;emquharg3@e-recht24.de\u0026#39;, \u0026#39;Female\u0026#39;, \u0026#39;1999-03-13\u0026#39;, \u0026#39;Mozambique\u0026#39;); INSERT INTO person (first_name, last_name, email, gender, date_of_birth, country_of_birth) VALUES (\u0026#39;Teodoro\u0026#39;, \u0026#39;Trimmill\u0026#39;, null, \u0026#39;Male\u0026#39;, \u0026#39;1982-04-30\u0026#39;, \u0026#39;China\u0026#39;); INSERT INTO person (first_name, last_name, email, gender, date_of_birth, country_of_birth) VALUES (\u0026#39;Reilly\u0026#39;, \u0026#39;Amesbury\u0026#39;, \u0026#39;ramesbury5@businessinsider.com\u0026#39;, \u0026#39;Male\u0026#39;, \u0026#39;1990-12-31\u0026#39;, \u0026#39;China\u0026#39;); INSERT INTO person (first_name, last_name, email, gender, date_of_birth, country_of_birth) VALUES (\u0026#39;West\u0026#39;, \u0026#39;Elphey\u0026#39;, null, \u0026#39;Male\u0026#39;, \u0026#39;2004-03-29\u0026#39;, \u0026#39;Indonesia\u0026#39;); INSERT INTO person (first_name, last_name, email, gender, date_of_birth, country_of_birth) VALUES (\u0026#39;Letta\u0026#39;, \u0026#39;Caurah\u0026#39;, \u0026#39;lcaurah7@yale.edu\u0026#39;, \u0026#39;Female\u0026#39;, \u0026#39;1994-09-09\u0026#39;, \u0026#39;Indonesia\u0026#39;); INSERT INTO person (first_name, last_name, email, gender, date_of_birth, country_of_birth) VALUES (\u0026#39;Elset\u0026#39;, \u0026#39;Agass\u0026#39;, \u0026#39;eagass8@rambler.ru\u0026#39;, \u0026#39;Female\u0026#39;, \u0026#39;2004-06-26\u0026#39;, \u0026#39;China\u0026#39;); INSERT INTO person (first_name, last_name, email, gender, date_of_birth, country_of_birth) VALUES (\u0026#39;Aurore\u0026#39;, \u0026#39;Drillingcourt\u0026#39;, \u0026#39;adrillingcourt9@cnet.com\u0026#39;, \u0026#39;Female\u0026#39;, \u0026#39;1977-10-19\u0026#39;, \u0026#39;China\u0026#39;); INSERT INTO person (first_name, last_name, email, gender, date_of_birth, country_of_birth) VALUES (\u0026#39;Ilse\u0026#39;, \u0026#39;Goldman\u0026#39;, \u0026#39;igoldmana@ihg.com\u0026#39;, \u0026#39;Female\u0026#39;, \u0026#39;2001-07-31\u0026#39;, \u0026#39;Mongolia\u0026#39;);    Let’s take a look at the two new tables to see what’s inside.\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 test=# SELECT * FROM person; id | first_name | last_name | email | gender | date_of_birth | country_of_birth | car_id ----+------------+---------------+--------------------------------+--------+---------------+------------------+-------- 1 | Hamid | Abbett | habbett1@cbc.ca | Male | 1995-08-31 | Ethiopia | 2 | Francis | Nickerson | fnickerson2@mac.com | Male | 1998-03-16 | Portugal | 3 | Erminie | M\u0026#39;Quharg | emquharg3@e-recht24.de | Female | 1999-03-13 | Mozambique | 4 | Teodoro | Trimmill | | Male | 1982-04-30 | China | 5 | Reilly | Amesbury | ramesbury5@businessinsider.com | Male | 1990-12-31 | China | 6 | West | Elphey | | Male | 2004-03-29 | Indonesia | 7 | Letta | Caurah | lcaurah7@yale.edu | Female | 1994-09-09 | Indonesia | 8 | Elset | Agass | eagass8@rambler.ru | Female | 2004-06-26 | China | 9 | Aurore | Drillingcourt | adrillingcourt9@cnet.com | Female | 1977-10-19 | China | 10 | Ilse | Goldman | igoldmana@ihg.com | Female | 2001-07-31 | Mongolia | (10 rows) test=# SELECT * FROM car; id | make | model | price ----+------------+------------------+----------- 1 | Daewoo | Leganza | 241058.40 2 | Mitsubishi | Montero | 269595.21 3 | Kia | Rio | 245275.16 4 | Jaguar | X-Type | 41665.96 5 | Lincoln | Mark VIII | 163843.38 6 | GMC | Rally Wagon 3500 | 231169.05 7 | Cadillac | Escalade ESV | 279951.34 (7 rows)    As expected, there is no value in the car_id column in person as we did not insert any value there.\n As can be seen below, we have set the foreign key correctly, and it has a UNIQUE constraint and car_id referencing to car.id.\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 test=# \\d person; Table \u0026#34;public.person\u0026#34; Column | Type | Collation | Nullable | Default ------------------+------------------------+-----------+----------+------------------------------------ id | bigint | | not null | nextval(\u0026#39;person_id_seq\u0026#39;::regclass) first_name | character varying(50) | | not null | last_name | character varying(50) | | not null | email | character varying(150) | | | gender | character varying(7) | | not null | date_of_birth | date | | not null | country_of_birth | character varying(50) | | not null | car_id | bigint | | | Indexes: \u0026#34;person_pkey\u0026#34; PRIMARY KEY, btree (id) \u0026#34;person_car_id_key\u0026#34; UNIQUE CONSTRAINT, btree (car_id) Foreign-key constraints: \u0026#34;person_car_id_fkey\u0026#34; FOREIGN KEY (car_id) REFERENCES car(id)    Let’s assign the Mitsubishi, which ID is 2 from the car table to Hamid Abbett of the person table which ID is 1.\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 test=# UPDATE person SET car_id = 2 WHERE id = 1; UPDATE 1 test=# SELECT * FROM person; id | first_name | last_name | email | gender | date_of_birth | country_of_birth | car_id ----+------------+---------------+--------------------------------+--------+---------------+------------------+-------- 2 | Francis | Nickerson | fnickerson2@mac.com | Male | 1998-03-16 | Portugal | 3 | Erminie | M\u0026#39;Quharg | emquharg3@e-recht24.de | Female | 1999-03-13 | Mozambique | 4 | Teodoro | Trimmill | | Male | 1982-04-30 | China | 5 | Reilly | Amesbury | ramesbury5@businessinsider.com | Male | 1990-12-31 | China | 6 | West | Elphey | | Male | 2004-03-29 | Indonesia | 7 | Letta | Caurah | lcaurah7@yale.edu | Female | 1994-09-09 | Indonesia | 8 | Elset | Agass | eagass8@rambler.ru | Female | 2004-06-26 | China | 9 | Aurore | Drillingcourt | adrillingcourt9@cnet.com | Female | 1977-10-19 | China | 10 | Ilse | Goldman | igoldmana@ihg.com | Female | 2001-07-31 | Mongolia | 1 | Hamid | Abbett | habbett1@cbc.ca | Male | 1995-08-31 | Ethiopia | 2 (10 rows)    Let’s also add a car to Francis Nickerson.\n 1 UPDATE person SET car_id = 1 WHERE id = 2;    Let’s try to give one car to two people and see what happens.\n 1 2 3 test=# UPDATE person SET car_id = 1 WHERE id = 3; ERROR: duplicate key value violates unique constraint \u0026#34;person_car_id_key\u0026#34; DETAIL: Key (car_id)=(1) already exists.    Okay, now assign other cars to specific persons. This is the final table.\n 1 2 3 4 5 6 7 8 9 10 11 12 13  id | first_name | last_name | email | gender | date_of_birth | country_of_birth | car_id ----+------------+---------------+--------------------------------+--------+---------------+------------------+-------- 5 | Reilly | Amesbury | ramesbury5@businessinsider.com | Male | 1990-12-31 | China | 9 | Aurore | Drillingcourt | adrillingcourt9@cnet.com | Female | 1977-10-19 | China | 10 | Ilse | Goldman | igoldmana@ihg.com | Female | 2001-07-31 | Mongolia | 1 | Hamid | Abbett | habbett1@cbc.ca | Male | 1995-08-31 | Ethiopia | 2 2 | Francis | Nickerson | fnickerson2@mac.com | Male | 1998-03-16 | Portugal | 1 3 | Erminie | M\u0026#39;Quharg | emquharg3@e-recht24.de | Female | 1999-03-13 | Mozambique | 7 4 | Teodoro | Trimmill | | Male | 1982-04-30 | China | 5 8 | Elset | Agass | eagass8@rambler.ru | Female | 2004-06-26 | China | 4 7 | Letta | Caurah | lcaurah7@yale.edu | Female | 1994-09-09 | Indonesia | 6 6 | West | Elphey | | Male | 2004-03-29 | Indonesia | 3 (10 rows)    1.6.1. Delete Record with Foreign Keys 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 test=# DELETE FROM car WHERE id = 7; ERROR: update or delete on table \u0026#34;car\u0026#34; violates foreign key constraint \u0026#34;person_car_id_fkey\u0026#34; on table \u0026#34;person\u0026#34; DETAIL: Key (id)=(7) is still referenced from table \u0026#34;person\u0026#34;. test=# DELETE FROM person WHERE id = 3; DELETE 1 test=# SELECT * FROM person; id | first_name | last_name | email | gender | date_of_birth | country_of_birth | car_id ----+------------+---------------+--------------------------------+--------+---------------+------------------+-------- 5 | Reilly | Amesbury | ramesbury5@businessinsider.com | Male | 1990-12-31 | China | 9 | Aurore | Drillingcourt | adrillingcourt9@cnet.com | Female | 1977-10-19 | China | 10 | Ilse | Goldman | igoldmana@ihg.com | Female | 2001-07-31 | Mongolia | 1 | Hamid | Abbett | habbett1@cbc.ca | Male | 1995-08-31 | Ethiopia | 2 2 | Francis | Nickerson | fnickerson2@mac.com | Male | 1998-03-16 | Portugal | 1 4 | Teodoro | Trimmill | | Male | 1982-04-30 | China | 5 8 | Elset | Agass | eagass8@rambler.ru | Female | 2004-06-26 | China | 4 7 | Letta | Caurah | lcaurah7@yale.edu | Female | 1994-09-09 | Indonesia | 6 6 | West | Elphey | | Male | 2004-03-29 | Indonesia | 3 (9 rows)    It turns out that we can’t delete a record which is assigned with the person table from the car table, but we can delete any record from the person table. This is because there is a relation from the person table to the car table.\n To delete a record from the car table, we have to delete the corresponding record in the person table or set the car_id of that record to NULL.\n   1.7. JOIN A JOIN clause is used to combine rows from two or more tables, based on a related column between them.\n 1.7.1. INNER JOIN The INNER JOIN keyword selects records that have matching values in both tables.\n The INNER JOIN creates a new result table by combining column values of two tables (table1 and table2) based upon the join-predicate. The query compares each row of table1 with each row of table2 to find all pairs of rows which satisfy the join-predicate. When the join-predicate is satisfied, column values for each matched pair of rows of A and B are combined into a result row.\n 1 2 3 4 SELECT column_name(s) FROM table1 INNER JOIN table2 ON table1.column_name = table2.column_name;    \n Now let’s join our tables based on foreign keys.\n Command\n 1 2 SELECT * FROM person JOIN car ON person.car_id = car.id;    Output\n 1 2 3 4 5 6 7 8 9 10  id | first_name | last_name | email | gender | date_of_birth | country_of_birth | car_id | id | make | model | price ----+------------+-----------+------------------------+--------+---------------+------------------+--------+----+------------+------------------+----------- 2 | Francis | Nickerson | fnickerson2@mac.com | Male | 1998-03-16 | Portugal | 1 | 1 | Daewoo | Leganza | 241058.40 1 | Hamid | Abbett | habbett1@cbc.ca | Male | 1995-08-31 | Ethiopia | 2 | 2 | Mitsubishi | Montero | 269595.21 6 | West | Elphey | | Male | 2004-03-29 | Indonesia | 3 | 3 | Kia | Rio | 245275.16 8 | Elset | Agass | eagass8@rambler.ru | Female | 2004-06-26 | China | 4 | 4 | Jaguar | X-Type | 41665.96 4 | Teodoro | Trimmill | | Male | 1982-04-30 | China | 5 | 5 | Lincoln | Mark VIII | 163843.38 7 | Letta | Caurah | lcaurah7@yale.edu | Female | 1994-09-09 | Indonesia | 6 | 6 | GMC | Rally Wagon 3500 | 231169.05 3 | Erminie | M\u0026#39;Quharg | emquharg3@e-recht24.de | Female | 1999-03-13 | Mozambique | 7 | 7 | Cadillac | Escalade ESV | 279951.34 (7 rows)    Command\n 1 2 3 SELECT person.first_name, person.last_name, car.make, car.model, car.price FROM person JOIN car ON person.car_id = car.id;    Output\n 1 2 3 4 5 6 7 8 9 10  first_name | last_name | make | model | price ------------+-----------+------------+------------------+----------- Francis | Nickerson | Daewoo | Leganza | 241058.40 Hamid | Abbett | Mitsubishi | Montero | 269595.21 West | Elphey | Kia | Rio | 245275.16 Elset | Agass | Jaguar | X-Type | 41665.96 Teodoro | Trimmill | Lincoln | Mark VIII | 163843.38 Letta | Caurah | GMC | Rally Wagon 3500 | 231169.05 Erminie | M\u0026#39;Quharg | Cadillac | Escalade ESV | 279951.34 (7 rows)     1.7.2. LEFT JOIN The LEFT JOIN keyword returns all records from the left table (table1), and the matched records from the right table (table2). The result is NULL from the right side, if there is no match.\n \n Command\n 1 2 3 SELECT person.first_name, person.last_name, car.make, car.model, car.price FROM person LEFT JOIN car ON person.car_id = car.id;    Output\n 1 2 3 4 5 6 7 8 9 10 11 12 13  first_name | last_name | make | model | price ------------+---------------+------------+------------------+----------- Francis | Nickerson | Daewoo | Leganza | 241058.40 Hamid | Abbett | Mitsubishi | Montero | 269595.21 West | Elphey | Kia | Rio | 245275.16 Elset | Agass | Jaguar | X-Type | 41665.96 Teodoro | Trimmill | Lincoln | Mark VIII | 163843.38 Letta | Caurah | GMC | Rally Wagon 3500 | 231169.05 Erminie | M\u0026#39;Quharg | Cadillac | Escalade ESV | 279951.34 Ilse | Goldman | | | Aurore | Drillingcourt | | | Reilly | Amesbury | | | (10 rows)     1.7.3. RIGHT JOIN The RIGHT JOIN keyword returns all records from the right table (table2), and the matched records from the left table (table1). The result is NULL from the left side, when there is no match.\n \n  1.7.4. FULL OUTER JOIN The FULL OUTER JOIN keyword returns all records when there are a match in left (table1) or right (table2) table records.\n Note: FULL OUTER JOIN can potentially return very large result-sets!\n FULL OUTER JOIN and FULL JOIN are the same.\n \n   1.8. Exporting Query Results to CSV By typing \\? and check the help. In the Input/Output section, it says that \\copy …​ perform SQL COPY with data stream to the client host.\n We will save this query to a CSV file.\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 test=# SELECT person.first_name, person.last_name, car.make, car.model, car.price FROM person LEFT JOIN car ON person.car_id = car.id; first_name | last_name | make | model | price ------------+---------------+------------+------------------+----------- Francis | Nickerson | Daewoo | Leganza | 241058.40 Hamid | Abbett | Mitsubishi | Montero | 269595.21 West | Elphey | Kia | Rio | 245275.16 Elset | Agass | Jaguar | X-Type | 41665.96 Teodoro | Trimmill | Lincoln | Mark VIII | 163843.38 Letta | Caurah | GMC | Rally Wagon 3500 | 231169.05 Ilse | Goldman | | | Aurore | Drillingcourt | | | Reilly | Amesbury | | | (9 rows)    Command\n 1 \\copy (SELECT person.first_name, person.last_name, car.make, car.model, car.price FROM person LEFT JOIN car ON car.id = person.car_id) TO \u0026#39;/home/arafat_hasan/Downloads/results.csv\u0026#39; DELIMITER \u0026#39;,\u0026#39; CSV HEADER    Output\n COPY 9   The query is stored in the CSV file.\n  1.9. Serials and Sequences 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 test=# \\d person; Table \u0026#34;public.person\u0026#34; Column | Type | Collation | Nullable | Default ------------------+------------------------+-----------+----------+------------------------------------ id | bigint | | not null | nextval(\u0026#39;person_id_seq\u0026#39;::regclass) first_name | character varying(50) | | not null | last_name | character varying(50) | | not null | email | character varying(150) | | | gender | character varying(7) | | not null | date_of_birth | date | | not null | country_of_birth | character varying(50) | | not null | car_id | bigint | | | Indexes: \u0026#34;person_pkey\u0026#34; PRIMARY KEY, btree (id) \u0026#34;person_car_id_key\u0026#34; UNIQUE CONSTRAINT, btree (car_id) Foreign-key constraints: \u0026#34;person_car_id_fkey\u0026#34; FOREIGN KEY (car_id) REFERENCES car(id) test=# SELECT * FROM person_id_seq ; last_value | log_cnt | is_called ------------+---------+----------- 10 | 23 | t (1 row) test=# SELECT nextval(\u0026#39;person_id_seq\u0026#39;::regclass); nextval --------- 11 (1 row) test=# SELECT nextval(\u0026#39;person_id_seq\u0026#39;::regclass); nextval --------- 12 (1 row) test=# SELECT * FROM person_id_seq ; last_value | log_cnt | is_called ------------+---------+----------- 12 | 32 | t (1 row) test=# ALTER SEQUENCE person_id_seq RESTART WITH 10; ALTER SEQUENCE test=# SELECT * FROM person_id_seq ; last_value | log_cnt | is_called ------------+---------+----------- 10 | 0 | f (1 row)     1.10. Extensions Simply extensions are functions that can add extra functionality to the database.\n List of available extensions\n 1 2 3 4 5 test=# SELECT * FROM pg_available_extensions; name | default_version | installed_version | comment ---------+-----------------+-------------------+------------------------------ plpgsql | 1.0 | 1.0 | PL/pgSQL procedural language (1 row)     1.11. UUID Datatype From wikipedia:\n  A universally unique identifier (UUID) is a 128-bit number used to identify information in computer systems. The term globally unique identifier (GUID) is also used, typically in software created by Microsoft.\n When generated according to the standard methods, UUIDs are, for practical purposes, unique. Their uniqueness does not depend on a central registration authority or coordination between the parties generating them, unlike most other numbering schemes. While the probability that a UUID will be duplicated is not zero, it is close enough to zero to be negligible.\n   We have to add the uuid-ossp extension:\n 1 CREATE EXTENSION \u0026#34;uuid-ossp\u0026#34;;    List of a available functions:\n 1 \\df    Now we have to invoke the function:\n 1 SELECT uuid_generate_v4();    1 ANLONGUUID    1.11.1. UUID as Primary Key Drop person and car table and create another ones as below.\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 CREATE TABLE car ( car_uid UUID NOT NULL PRIMARY KEY, make VARCHAR(100) NOT NULL, model VARCHAR(100) NOT NULL, price NUMERIC(19, 2) NOT NULL ); CREATE TABLE person ( person_uid UUID NOT NULL PRIMARY KEY, first_name VARCHAR(50) NOT NULL, last_name VARCHAR(50) NOT NULL, email VARCHAR(150), gender VARCHAR(7) NOT NULL, date_of_birth DATE NOT NULL, country_of_birth VARCHAR(50) NOT NULL, car_uid UUID REFERENCES car(car_uid), UNIQUE(car_uid), UNIQUE(email) ); INSERT INTO car (car_uid, make, model, price) VALUES (uuid_generate_v4(), uuid_generate_v4(), \u0026#39;Mitsubishi\u0026#39;, \u0026#39;Montero\u0026#39;, \u0026#39;269595.21\u0026#39;); INSERT INTO car (car_uid, make, model, price) VALUES (uuid_generate_v4(), uuid_generate_v4(), \u0026#39;Kia\u0026#39;, \u0026#39;Rio\u0026#39;, \u0026#39;245275.16\u0026#39;); INSERT INTO car (car_uid, make, model, price) VALUES (uuid_generate_v4(), uuid_generate_v4(), \u0026#39;Jaguar\u0026#39;, \u0026#39;X-Type\u0026#39;, \u0026#39;41665.96\u0026#39;); INSERT INTO car (car_uid, make, model, price) VALUES (uuid_generate_v4(), uuid_generate_v4(), \u0026#39;Lincoln\u0026#39;, \u0026#39;Mark VIII\u0026#39;, \u0026#39;163843.38\u0026#39;); INSERT INTO person (person_uid, first_name, last_name, email, gender, date_of_birth, country_of_birth) VALUES (uuid_generate_v4(), uuid_generate_v4(), \u0026#39;Hamid\u0026#39;, \u0026#39;Abbett\u0026#39;, \u0026#39;habbett1@cbc.ca\u0026#39;, \u0026#39;Male\u0026#39;, \u0026#39;1995-08-31\u0026#39;, \u0026#39;Ethiopia\u0026#39;); INSERT INTO person (person_uid, first_name, last_name, email, gender, date_of_birth, country_of_birth) VALUES (uuid_generate_v4(), uuid_generate_v4(), \u0026#39;Francis\u0026#39;, \u0026#39;Nickerson\u0026#39;, \u0026#39;fnickerson2@mac.com\u0026#39;, \u0026#39;Male\u0026#39;, \u0026#39;1998-03-16\u0026#39;, \u0026#39;Portugal\u0026#39;); INSERT INTO person (person_uid, first_name, last_name, email, gender, date_of_birth, country_of_birth) VALUES (uuid_generate_v4(), uuid_generate_v4(), \u0026#39;Erminie\u0026#39;, \u0026#39;M\u0026#39;\u0026#39;Quharg\u0026#39;, \u0026#39;emquharg3@e-recht24.de\u0026#39;, \u0026#39;Female\u0026#39;, \u0026#39;1999-03-13\u0026#39;, \u0026#39;Mozambique\u0026#39;); INSERT INTO person (person_uid, first_name, last_name, email, gender, date_of_birth, country_of_birth) VALUES (uuid_generate_v4(), uuid_generate_v4(), \u0026#39;Teodoro\u0026#39;, \u0026#39;Trimmill\u0026#39;, null, \u0026#39;Male\u0026#39;, \u0026#39;1982-04-30\u0026#39;, \u0026#39;China\u0026#39;); INSERT INTO person (person_uid, first_name, last_name, email, gender, date_of_birth, country_of_birth) VALUES (uuid_generate_v4(), uuid_generate_v4(), \u0026#39;Reilly\u0026#39;, \u0026#39;Amesbury\u0026#39;, \u0026#39;ramesbury5@businessinsider.com\u0026#39;, \u0026#39;Male\u0026#39;, \u0026#39;1990-12-31\u0026#39;, \u0026#39;China\u0026#39;); INSERT INTO person (person_uid, first_name, last_name, email, gender, date_of_birth, country_of_birth) VALUES (uuid_generate_v4(), uuid_generate_v4(), \u0026#39;West\u0026#39;, \u0026#39;Elphey\u0026#39;, null, \u0026#39;Male\u0026#39;, \u0026#39;2004-03-29\u0026#39;, \u0026#39;Indonesia\u0026#39;); INSERT INTO person (person_uid, first_name, last_name, email, gender, date_of_birth, country_of_birth) VALUES (uuid_generate_v4(), uuid_generate_v4(), \u0026#39;Letta\u0026#39;, \u0026#39;Caurah\u0026#39;, \u0026#39;lcaurah7@yale.edu\u0026#39;, \u0026#39;Female\u0026#39;, \u0026#39;1994-09-09\u0026#39;, \u0026#39;Indonesia\u0026#39;);        ","permalink":"https://arafat-hasan.github.io/en/post/postgres-sallow-sea/","tags":["postgresql","note","postgres"],"title":"PostgreSQL: The Sallow Sea"},{"categories":["professional writings"],"contents":" This writing is actually a draft note made for me so that I myself don’t forget what I have learned. For that, I think this note will be helpful for those who want to learn new Postgres.\n 1. The Surface Sea 1.1. Mockaroo Data Generator We will use a site named Mockaroo to insert a lot of data into our table for our learning convenience. Mockaroo is an online realist test data generator. We will download a bunch of dummy but realistic data in SQL format and execute the SQL file in the terminal.\n \n Notes:\n   Field Names and types in Mockaroo according to the image above.\n  For our learning convenience, make sure 30% blank in the email field.\n  Set a acceptable nice range for data of birth.\n  To find the type of each field, we have to search with the appropriate keyword.\n  Tick the include create table option.\n   Download the data as a file named person.sql.\n Now we will do some tweaking in person.sql, according to our needs. Open this file in the preferred editor, I’m using vs code. Then make the following changes to the CREATE TABLE command at the top of the file. Notice that we have added id BIGSERIAL NOT NULL PRIMARY KEY, changed VARCHAR sizes, and specified the NOT NULL fields.\n 1 2 3 4 5 6 7 8 9 10 create table person ( id BIGSERIAL NOT NULL PRIMARY KEY, first_name VARCHAR(50) NOT NULL, last_name VARCHAR(50) NOT NULL, email VARCHAR(150), gender VARCHAR(7) NOT NULL, date_of_birth DATE NOT NULL, country_of_birth VARCHAR(50) NOT NULL ); -- More lines containing INSERT command, We are not showing them here.    After saving our changed person.sql file, now we will execute it. We can copy the whole file and paste it into Postgres terminal, that will work too, but we are going to do it in a better way. \\i executes a script file of SQL commands.\n test=# \\i /path/to/person.sql   Now the script person.sql is executed, and there are 1000 rows in the person table.\n Our table description look like this:\n 1 2 3 4 5 6 7 8 9 10 test=# \\d person; Table \u0026#34;public.person\u0026#34; Column | Type | Collation | Nullable | Default ------------------+------------------------+-----------+----------+--------- first_name | character varying(50) | | not null | last_name | character varying(50) | | not null | email | character varying(150) | | | gender | character varying(7) | | not null | date_of_birth | date | | not null | country_of_birth | character varying(50) | | not null |    Here we have made a query to fetch all the data from the person table.\n Command\n SELECT * FROM person;   Output\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  id | first_name | last_name | email | gender | date_of_birth | country_of_birth ------+----------------+---------------------+-----------------------------------------+--------+---------------+---------------------------------- 1 | Ronda | Skermer | rskermer0@arstechnica.com | Female | 1993-06-30 | Argentina 2 | Hamid | Abbett | habbett1@cbc.ca | Male | 1995-08-31 | Ethiopia 3 | Francis | Nickerson | fnickerson2@mac.com | Male | 1998-03-16 | Portugal 4 | Erminie | M\u0026#39;Quharg | emquharg3@e-recht24.de | Female | 1999-03-13 | Mozambique 5 | Teodoro | Trimmill | | Male | 1982-04-30 | China 6 | Reilly | Amesbury | ramesbury5@businessinsider.com | Male | 1990-12-31 | China 7 | West | Elphey | | Male | 2004-03-29 | Indonesia 8 | Letta | Caurah | lcaurah7@yale.edu | Female | 1994-09-09 | Indonesia 9 | Elset | Agass | eagass8@rambler.ru | Female | 2004-06-26 | China 10 | Aurore | Drillingcourt | adrillingcourt9@cnet.com | Female | 1977-10-19 | China 11 | Ilse | Goldman | igoldmana@ihg.com | Female | 2001-07-31 | Mongolia 12 | Penny | Nayer | pnayerb@harvard.edu | Female | 1969-02-05 | Colombia 13 | Neale | Dubery | nduberyc@soundcloud.com | Male | 1975-12-22 | Portugal 14 | Gnni | Dickman | gdickmand@people.com.cn | Female | 1977-10-12 | Guatemala 15 | Flori | Giroldi | fgiroldie@ameblo.jp | Female | 1975-11-14 | China --More--    Alternatively, we can specify our required field names:\n Command\n SELECT id, first_name, last_name FROM person;   Output\n 1 2 3 4 5 6 7 8 9 10 11 12 13  id | first_name | last_name ------+----------------+--------------------- 1 | Ronda | Skermer 2 | Hamid | Abbett 3 | Francis | Nickerson 4 | Erminie | M\u0026#39;Quharg 5 | Teodoro | Trimmill 6 | Reilly | Amesbury 7 | West | Elphey 8 | Letta | Caurah 9 | Elset | Agass 10 | Aurore | Drillingcourt --More--     1.2. ORDER BY The ORDER BY keyword is used to sort the result-set in ascending (ASC) or descending (DESC) order. The ORDER BY keyword sorts the records in ascending order by default. To sort the records in ascending order, use the DESC keyword.\n 1.2.1. ASC For ascending order:\n Command\n SELECT * FROM person ORDER BY country_of_birth;   Output\n 1 2 3 4 5 6 7 8 9 10 11 12  id | first_name | last_name | email | gender | date_of_birth | country_of_birth ------+----------------+---------------------+-----------------------------------------+--------+---------------+---------------------------------- 475 | Koren | Burgen | | Female | 1985-09-16 | Afghanistan 223 | Collen | Raubheim | craubheim66@gravatar.com | Female | 1968-01-31 | Afghanistan 331 | Vaughan | Borles | vborles96@behance.net | Male | 1987-09-08 | Albania 831 | Cordy | Aries | | Male | 2007-07-06 | Albania 662 | Una | Chevis | uchevisid@whitehouse.gov | Female | 2001-10-03 | Albania 993 | Delmar | Sparham | | Male | 2000-01-24 | Albania 583 | Nikolia | Whodcoat | nwhodcoatg6@army.mil | Female | 1993-01-01 | Albania 751 | Kyrstin | Wimpenny | kwimpennyku@slideshare.net | Female | 1986-07-12 | Algeria 837 | Dalis | McLinden | | Male | 1989-09-24 | Angola --More--     1.2.2. DESC For dscending order:\n Command\n SELECT * FROM person ORDER BY country_of_birth DESC;   Output\n 1 2 3 4 5 6 7 8 9 10 11 12 13  id | first_name | last_name | email | gender | date_of_birth | country_of_birth ------+----------------+---------------------+-----------------------------------------+--------+---------------+---------------------------------- 563 | Meredeth | Pantin | | Male | 1971-02-22 | Zambia 173 | Pennie | Christauffour | pchristauffour4s@scientificamerican.com | Male | 2004-04-16 | Zambia 947 | Saidee | Daffern | sdaffernqa@barnesandnoble.com | Female | 1973-03-11 | Yemen 742 | Lacee | Sumner | lsumnerkl@icio.us | Female | 2007-03-31 | Yemen 520 | Clerissa | Mockett | | Female | 1980-12-08 | Yemen 89 | Robinson | Tichner | | Male | 2005-12-09 | Yemen 754 | Oren | Eidler | oeidlerkx@typepad.com | Male | 1969-02-23 | Yemen 725 | Sadye | Garman | | Female | 1985-11-05 | Yemen 537 | Isadore | Tasker | itaskerew@example.com | Male | 1977-03-05 | Vietnam 602 | Nevins | Blenkinship | nblenkinshipgp@psu.edu | Male | 2010-02-04 | Vietnam --More--    Date of birth in dscending order:\n Command\n SELECT * FROM person ORDER BY date_of_birth DESC;   Output\n 1 2 3 4 5 6 7 8 9 10 11 12 13  id | first_name | last_name | email | gender | date_of_birth | country_of_birth ------+----------------+---------------------+-----------------------------------------+--------+---------------+---------------------------------- 307 | Penni | Privost | | Female | 2010-08-07 | Indonesia 43 | Kathye | Bottleson | kbottleson16@google.pl | Female | 2010-06-27 | China 616 | Darryl | Craw | dcrawh3@nba.com | Male | 2010-05-30 | Guatemala 549 | Paulie | Durante | pdurantef8@go.com | Female | 2010-05-09 | Russia 983 | Elka | Chyuerton | | Female | 2010-04-28 | China 533 | Leslie | Lusgdin | llusgdines@creativecommons.org | Female | 2010-04-20 | Bosnia and Herzegovina 248 | Shurwood | Vezey | svezey6v@amazon.com | Male | 2010-04-15 | Indonesia 974 | Noll | Pidgin | npidginr1@wiley.com | Male | 2010-04-13 | Indonesia 676 | Edwina | Presdee | epresdeeir@icio.us | Female | 2010-04-10 | China 813 | Terri | Blockey | tblockeymk@gnu.org | Female | 2010-04-08 | China --More--     1.2.3. ORDER BY with Two-parameter This means that if country_of_birth is the same, then the rows will be sorted according to the id column. Check the difference with the previous one and this.\n Command\n SELECT * FROM person ORDER BY country_of_birth, id;   Output\n 1 2 3 4 5 6 7 8 9  id | first_name | last_name | email | gender | date_of_birth | country_of_birth ------+----------------+---------------------+-----------------------------------------+--------+---------------+---------------------------------- 223 | Collen | Raubheim | craubheim66@gravatar.com | Female | 1968-01-31 | Afghanistan 475 | Koren | Burgen | | Female | 1985-09-16 | Afghanistan 331 | Vaughan | Borles | vborles96@behance.net | Male | 1987-09-08 | Albania 583 | Nikolia | Whodcoat | nwhodcoatg6@army.mil | Female | 1993-01-01 | Albania 662 | Una | Chevis | uchevisid@whitehouse.gov | Female | 2001-10-03 | Albania 831 | Cordy | Aries | | Male | 2007-07-06 | Albania --More--      1.3. DISTINCT The SELECT DISTINCT statement is used to return only distinct (different) values.\n Command\n SELECT DISTINCT country_of_birth FROM person ORDER BY country_of_birth;   Output\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  country_of_birth ---------------------------------- Afghanistan Albania Algeria Angola Argentina Armenia Australia Azerbaijan Bangladesh Belarus Benin Bolivia Bosnia and Herzegovina Brazil --More--     1.4. WHERE The WHERE clause is used to extract only those records that fulfill a specified condition.\n Command\n SELECT * FROM person WHERE gender=\u0026#39;Female\u0026#39;;   Output\n 1 2 3 4 5 6 7 8 9 10  id | first_name | last_name | email | gender | date_of_birth | country_of_birth -----+----------------+---------------------+---------------------------------------+--------+---------------+-------------------------- 1 | Ronda | Skermer | rskermer0@arstechnica.com | Female | 1993-06-30 | Argentina 4 | Erminie | M\u0026#39;Quharg | emquharg3@e-recht24.de | Female | 1999-03-13 | Mozambique 8 | Letta | Caurah | lcaurah7@yale.edu | Female | 1994-09-09 | Indonesia 9 | Elset | Agass | eagass8@rambler.ru | Female | 2004-06-26 | China 10 | Aurore | Drillingcourt | adrillingcourt9@cnet.com | Female | 1977-10-19 | China 11 | Ilse | Goldman | igoldmana@ihg.com | Female | 2001-07-31 | Mongolia 12 | Penny | Nayer | pnayerb@harvard.edu | Female | 1969-02-05 | Colombia --More--    1.4.1. BETWEEN The BETWEEN operator selects values within a given range. The values can be numbers, text, or dates.\n The BETWEEN operator is inclusive: begin and end values are included.\n Command\n SELECT * FROM person WHERE date_of_birth BETWEEN \u0026#39;1985-02-02\u0026#39; AND \u0026#39;1986-06-04\u0026#39;;   Output\n 1 2 3 4 5 6 7 8 9 10 11  id | first_name | last_name | email | gender | date_of_birth | country_of_birth -----+------------+--------------+------------------------------+--------+---------------+----------------------- 25 | Billi | Dybbe | bdybbeo@samsung.com | Female | 1986-02-22 | Brazil 37 | Sorcha | Tunesi | stunesi10@adobe.com | Female | 1986-04-12 | Philippines 45 | Carleen | Dzeniskevich | cdzeniskevich18@disqus.com | Female | 1985-06-18 | China 103 | Oberon | Sparry | osparry2u@yellowbook.com | Male | 1985-09-22 | China 125 | Cal | Shurville | cshurville3g@1und1.de | Male | 1986-01-29 | Qatar 157 | Juline | Wanek | | Female | 1985-11-30 | Sweden 162 | Amelia | Braferton | | Female | 1986-05-03 | New Zealand 168 | West | Glowacz | wglowacz4n@yolasite.com | Male | 1985-12-02 | Canada --More--     1.4.2. LIKE The LIKE operator is used in a WHERE clause to search for a specified pattern in a column.\n There are two wildcards often used in conjunction with the LIKE operator:\n   %: The percent sign represents zero, one, or multiple characters\n  _: The underscore represents a single character\n   Find all emails ending with disqus.com:\n Command\n SELECT * FROM person WHERE email LIKE \u0026#39;%disqus.com\u0026#39;;   Output\n 1 2 3 4 5  id | first_name | last_name | email | gender | date_of_birth | country_of_birth -----+------------+--------------+----------------------------+--------+---------------+------------------ 45 | Carleen | Dzeniskevich | cdzeniskevich18@disqus.com | Female | 1985-06-18 | China 852 | Alex | Garmans | agarmansnn@disqus.com | Male | 1990-11-08 | China (2 rows)      1.5. GROUP BY The GROUP BY statement groups rows that have the same values into summary rows, like \u0026#34;find the number of persons in each country\u0026#34;.\n The GROUP BY statement is often used with aggregate functions (COUNT, MAX, MIN, SUM, AVG) to group the result-set by one or more columns.\n Command\n SELECT country_of_birth, COUNT(*) FROM person GROUP BY country_of_birth;   Output\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14  country_of_birth | count ----------------------------------+------- Bangladesh | 1 Indonesia | 109 Venezuela | 5 Cameroon | 3 Czech Republic | 18 Sweden | 31 Dominican Republic | 7 Ireland | 3 Macedonia | 4 Papua New Guinea | 2 Sri Lanka | 1 --More--    1.5.1. GROUP BY with ORDER BY Command\n SELECT country_of_birth, COUNT(*) FROM person GROUP BY country_of_birth ORDER BY country_of_birth;   Output\n 1 2 3 4 5 6 7 8 9 10 11 12  country_of_birth | count ----------------------------------+------- Afghanistan | 2 Albania | 5 Algeria | 1 Angola | 2 Argentina | 20 Armenia | 5 Australia | 1 Azerbaijan | 3 Bangladesh | 1 --More--     1.5.2. GROUP BY HAVING The HAVING clause was added to SQL because the WHERE keyword could not be used with aggregate functions.\n Command\n SELECT country_of_birth, COUNT(*) FROM person GROUP BY country_of_birth HAVING COUNT(*) \u0026gt; 50 ORDER BY country_of_birth;   Output\n 1 2 3 4 5 6  country_of_birth | count ------------------+------- China | 180 Indonesia | 109 Russia | 56 (3 rows)      1.6. COALESCE The COALESCE() function returns the first non-null value in a list.\n Command\n SELECT COALESCE(email, \u0026#39;Email not provided\u0026#39;) FROM person;   Output\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  coalesce ----------------------------------------- rskermer0@arstechnica.com habbett1@cbc.ca fnickerson2@mac.com emquharg3@e-recht24.de Email not provided ramesbury5@businessinsider.com Email not provided lcaurah7@yale.edu eagass8@rambler.ru adrillingcourt9@cnet.com igoldmana@ihg.com pnayerb@harvard.edu --More--     1.7. Another Table Called car Now we will download a new bunch of data to create another table called car. This table has these columns: - id: Primary key - make: Company name of the car - model: Model of the car - price: Price of the car, price between in a nice range\n ![Generate data using Mockaroo](https://imgur.com/z93rIG7.jpg \u0026#34;:Generate data using Mockaroo\u0026#34;)\n Now edit the downloded file car.sql a bit—\n 1 2 3 4 5 6 7 8 create table car ( id BIGSERIAL NOT NULL PRIMARY KEY, make VARCHAR(100) NOT NULL, model VARCHAR(100) NOT NULL, price NUMERIC(19, 2) NOT NULL ); -- More lines containing INSERT command, We are not showing them here.    After saving our changed car.sql file, now we will execute it.\n test=# \\i /path/to/car.sql   Here is first 10 rows from car table. LIMIT is used to get only first 10 rows.\n Command\n SELECT * FROM car LIMIT 10;   Output\n 1 2 3 4 5 6 7 8 9 10 11 12 13  id | make | model | price ----+------------+------------------+----------- 1 | Daewoo | Leganza | 241058.40 2 | Mitsubishi | Montero | 269595.21 3 | Kia | Rio | 245275.16 4 | GMC | Savana 1500 | 217435.26 5 | Jaguar | X-Type | 41665.96 6 | Lincoln | Mark VIII | 163843.38 7 | GMC | Rally Wagon 3500 | 231169.05 8 | Cadillac | Escalade ESV | 279951.34 9 | Volvo | XC70 | 269436.96 10 | Isuzu | Rodeo | 65421.58 (10 rows)     1.8. Basic Functions 1.8.1. MAX The MAX() function returns the largest value of the selected column.\n Command\n SELECT MAX(price) FROM car;   Output\n 1 2 3 4  max ----------- 299959.83 (1 row)    Command\n SELECT make, MAX(price) FROM car GROUP BY make LIMIT 5;   Output\n 1 2 3 4 5 6 7 8  make | max ----------+----------- Ford | 290993.39 Smart | 159887.95 Maserati | 221349.10 Dodge | 299766.43 Infiniti | 298245.19 (5 rows)     1.8.2. MIN The MIN() function returns the smallest value of the selected column.\n Command\n SELECT MIN(price) FROM car;   Output\n 1 2 3 4  min ---------- 30348.16 (1 row)    Command\n SELECT make, MIN(price) FROM car GROUP BY make LIMIT 5;   Output\n 1 2 3 4 5 6 7 8  make | min ----------+----------- Ford | 31021.48 Smart | 159887.95 Maserati | 38668.83 Dodge | 33495.17 Infiniti | 47912.88 (5 rows)     1.8.3. AVG The AVG() function returns the average value of a numeric column.\n Command\n SELECT AVG(price) FROM car;   Output\n 1 2 3 4  avg --------------------- 164735.601300000000 (1 row)    Command\n SELECT make, AVG(price) FROM car GROUP BY make LIMIT 5;   Output\n 1 2 3 4 5 6 7 8  make | avg ----------+--------------------- Ford | 171967.729473684211 Smart | 159887.950000000000 Maserati | 122897.857500000000 Dodge | 166337.502307692308 Infiniti | 179690.643846153846 (5 rows)     1.8.4. ROUND The PostgreSQL ROUND() function rounds a numeric value to its nearest integer or a number with the number of decimal places.\n Command\n SELECT ROUND(AVG(price)) FROM car;   Output\n 1 2 3 4  round -------- 164736 (1 row)    Command\n SELECT make, ROUND(AVG(price)) FROM car GROUP BY make LIMIT 5;   Output\n 1 2 3 4 5 6 7 8 9  make | round ----------+-------- Ford | 171968 Smart | 159888 Maserati | 122898 Dodge | 166338 Infiniti | 179691 (5 rows)     1.8.5. COUNT The COUNT() function returns the number of rows that match a specified criterion.\n Command\n SELECT COUNT(make) FROM car;   Output\n 1 2 3 4  count ------- 1000 (1 row)     1.8.6. SUM The SUM() function returns the total sum of a numeric column.\n Command\n SELECT SUM(price) FROM car;   Output\n 1 2 3 4  sum -------------- 164735601.30 (1 row)    Command\n SELECT make, SUM(price) FROM car GROUP BY make LIMIT 5;   Output\n 1 2 3 4 5 6 7 8  make | sum ----------+------------- Ford | 16336934.30 Smart | 159887.95 Maserati | 491591.43 Dodge | 8649550.12 Infiniti | 2335978.37 (5 rows)      1.9. Basic Arithmetic Operations Command\n SELECT 10 + 2;   Output\n 1 2 3 4  ?column? ---------- 12 (1 row)    Command\n SELECT 10 / 2;   Output\n 1 2 3 4  ?column? ---------- 5 (1 row)    Command\n SELECT 10^2;   Output\n 1 2 3 4  ?column? ---------- 100 (1 row)     1.10. Discount Calculation Now suppose the company offers a 10% discount on all cars. We will now calculate the amount of this 10%, and calculate the new price.\n Command\n SELECT id, make, model, price, ROUND(price * 0.10, 2), ROUND(price - (price * 0.10), 2) FROM car;   Output\n 1 2 3 4 5 6 7 8 9 10 11 12 13  id | make | model | price | round | round ------+---------------+----------------------+-----------+----------+----------- 1 | Daewoo | Leganza | 241058.40 | 24105.84 | 216952.56 2 | Mitsubishi | Montero | 269595.21 | 26959.52 | 242635.69 3 | Kia | Rio | 245275.16 | 24527.52 | 220747.64 4 | GMC | Savana 1500 | 217435.26 | 21743.53 | 195691.73 5 | Jaguar | X-Type | 41665.96 | 4166.60 | 37499.36 6 | Lincoln | Mark VIII | 163843.38 | 16384.34 | 147459.04 7 | GMC | Rally Wagon 3500 | 231169.05 | 23116.91 | 208052.15 8 | Cadillac | Escalade ESV | 279951.34 | 27995.13 | 251956.21 9 | Volvo | XC70 | 269436.96 | 26943.70 | 242493.26 10 | Isuzu | Rodeo | 65421.58 | 6542.16 | 58879.42 --More--    ROUND (source [ , n ] ) function rounds a numeric value to its nearest integer or a number with the number of decimal places. Where The source argument is a number or a numeric expression that is to be rounded and the n argument is an integer that determines the number of decimal places after rounding.\n  1.11. ALIAS SQL aliases are used to give a table, or a column in a table, a temporary name. Aliases are often used to make column names more readable. An alias only exists for the duration of the query.\n Command\n 1 2 3 4 SELECT id, make, model, price AS original_price, ROUND(price * 0.10, 2) AS ten_percent_discount, ROUND(price - (price * 0.10), 2) AS discounted_price FROM car;    Output\n 1 2 3 4 5 6 7 8 9 10 11 12 13  id | make | model | original_price | ten_percent_discount | discounted_price ------+---------------+----------------------+----------------+----------------------+------------------ 1 | Daewoo | Leganza | 241058.40 | 24105.84 | 216952.56 2 | Mitsubishi | Montero | 269595.21 | 26959.52 | 242635.69 3 | Kia | Rio | 245275.16 | 24527.52 | 220747.64 4 | GMC | Savana 1500 | 217435.26 | 21743.53 | 195691.73 5 | Jaguar | X-Type | 41665.96 | 4166.60 | 37499.36 6 | Lincoln | Mark VIII | 163843.38 | 16384.34 | 147459.04 7 | GMC | Rally Wagon 3500 | 231169.05 | 23116.91 | 208052.15 8 | Cadillac | Escalade ESV | 279951.34 | 27995.13 | 251956.21 9 | Volvo | XC70 | 269436.96 | 26943.70 | 242493.26 10 | Isuzu | Rodeo | 65421.58 | 6542.16 | 58879.42 --More--     1.12. NULLIF The NULLIF() function returns NULL if two expressions are equal. Otherwise, it returns the first expression.\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 test=# SELECT NULLIF(2, 1); nullif -------- 2 (1 row) test=# SELECT NULLIF(\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;); nullif -------- a (1 row) test=# SELECT NULLIF(0, 0); nullif -------- (1 row)     1.13. DATE PostgreSQL provides several functions that return values related to the current date and time. These SQL-standard functions all return values based on the start time of the current transaction:\n 1 2 3 4 CURRENT_DATE CURRENT_TIME CURRENT_TIMESTAMP CURRENT_TIME(precision)    1 2 3 4 5 6 7 8 SELECT CURRENT_TIME; Result: 14:39:53.662522-05 SELECT CURRENT_DATE; Result: 2001-12-23 SELECT CURRENT_TIMESTAMP; Result: 2001-12-23 14:39:53.662522-05    PostgreSQL also provides functions that return the start time of the current statement, as well as the actual current time at the instant the function is called. The complete list of non-SQL-standard time functions is:\n 1 2 3 4 5 transaction_timestamp() statement_timestamp() clock_timestamp() timeofday() now()    1.13.1. NOW 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 test=# SELECT NOW(); now ------------------------------ 2020-08-19 23:39:49.18778+06 (1 row) test=# SELECT NOW()::DATE; now ------------ 2020-08-19 (1 row) test=# SELECT NOW()::TIME; now ----------------- 23:40:44.645625 (1 row)     1.13.2. Addition and Subtraction of Date INTERVAL 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 test=# SELECT NOW() - INTERVAL \u0026#39;1 YEAR\u0026#39;; ?column? ------------------------------- 2019-08-19 23:47:11.475305+06 (1 row) test=# SELECT NOW() - INTERVAL \u0026#39;10 YEAR\u0026#39;; ?column? ------------------------------- 2010-08-19 23:47:31.627347+06 (1 row) test=# SELECT NOW() - INTERVAL \u0026#39;3 MONTHS\u0026#39;; ?column? ------------------------------- 2020-05-19 23:47:53.403383+06 (1 row) test=# SELECT NOW() + INTERVAL \u0026#39;40 DAYS\u0026#39;; ?column? ------------------------------- 2020-09-28 23:48:31.419856+06 (1 row)      1.13.3. EXTRACT The extract function retrieves subfields such as year or hour from date/time values. source must be a value expression of type timestamp, time, or interval. (Expressions of type date are cast to timestamp and can, therefore, be used as well.) field is an identifier or string that selects what field to extract from the source value. The extract function returns values of type double precision.\n EXTRACT(field FROM source)   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 test=# SELECT NOW(); now ------------------------------ 2020-08-19 23:55:42.13778+06 (1 row) test=# SELECT EXTRACT(YEAR FROM NOW()); date_part ----------- 2020 (1 row) test=# SELECT EXTRACT(MONTH FROM NOW()); date_part ----------- 8 (1 row) test=# SELECT EXTRACT(CENTURY FROM NOW()); date_part ----------- 21 (1 row)     1.13.4. AGE age(timestamp, timestamp)   or\n age(timestamp)   The return type of both is an interval.\n Command\n SELECT first_name, last_name, gender, date_of_birth, AGE(NOW(), date_of_birth) AS age FROM person;   Output\n 1 2 3 4 5 6 7 8 9 10 11 12  first_name | last_name | gender | date_of_birth | age ----------------+---------------------+--------+---------------+------------------------------------------ Ronda | Skermer | Female | 1993-06-30 | 27 years 1 mon 19 days 23:56:04.414053 Hamid | Abbett | Male | 1995-08-31 | 24 years 11 mons 19 days 23:56:04.414053 Francis | Nickerson | Male | 1998-03-16 | 22 years 5 mons 3 days 23:56:04.414053 Erminie | M\u0026#39;Quharg | Female | 1999-03-13 | 21 years 5 mons 6 days 23:56:04.414053 Teodoro | Trimmill | Male | 1982-04-30 | 38 years 3 mons 19 days 23:56:04.414053 Reilly | Amesbury | Male | 1990-12-31 | 29 years 7 mons 19 days 23:56:04.414053 West | Elphey | Male | 2004-03-29 | 16 years 4 mons 21 days 23:56:04.414053 Letta | Caurah | Female | 1994-09-09 | 25 years 11 mons 10 days 23:56:04.414053 Elset | Agass | Female | 2004-06-26 | 16 years 1 mon 23 days 23:56:04.414053 --More--    See More: Date/Time Types\n     ","permalink":"https://arafat-hasan.github.io/en/post/postgres-surface-sea/","tags":["postgresql","note","postgres"],"title":"PostgreSQL: The Surface Sea"},{"categories":["professional writings"],"contents":" This writing is actually a draft note made for me so that I myself don’t forget what I have learned. For that, I think this note will be helpful for those who want to learn new Postgres.\n 1. Some Very First Commands   \\q: Quit/Exit\n  \\l: List all databases in the current PostgreSQL database server\n  \\h: Show the list of SQL commands\n  \\c database: Connect to a database\n  \\d: To describe (list) what tables are in the database\n  \\d table: Show table definition (columns, etc.) including triggers\n  \\i filename: to run (include) a script file of SQL commands\n  \\w filename: To write the last SQL command to a file\n  \\h command: Show syntax on this SQL command\n  \\?: Show the list of postgres commands\n   1.1. Examples [arafat@server ~]$ psql psql (12.3) Type \u0026amp;quot;help\u0026amp;quot; for help. arafat=# \\l List of databases Name | Owner | Encoding | Collate | Ctype | Access privileges --------------+----------+----------+-------------+-------------+----------------------- arafat | postgres | UTF8 | en_US.UTF-8 | en_US.UTF-8 | postgres | postgres | UTF8 | en_US.UTF-8 | en_US.UTF-8 | template0 | postgres | UTF8 | en_US.UTF-8 | en_US.UTF-8 | =c/postgres + | | | | | postgres=CTc/postgres template1 | postgres | UTF8 | en_US.UTF-8 | en_US.UTF-8 | =c/postgres + | | | | | postgres=CTc/postgres (4 rows) arafat=# \\h CREATE DATABASE; Command: CREATE DATABASE Description: create a new database Syntax: CREATE DATABASE name [ [ WITH ] [ OWNER [=] user_name ] [ TEMPLATE [=] template ] [ ENCODING [=] encoding ] [ LC_COLLATE [=] lc_collate ] [ LC_CTYPE [=] lc_ctype ] [ TABLESPACE [=] tablespace_name ] [ ALLOW_CONNECTIONS [=] allowconn ] [ CONNECTION LIMIT [=] connlimit ] [ IS_TEMPLATE [=] istemplate ] ] URL: https://www.postgresql.org/docs/12/sql-createdatabase.html    1.2. CREATE DATABASE arafat=# CREATE DATABASE test; CREATE DATABASE arafat=# \\l List of databases Name | Owner | Encoding | Collate | Ctype | Access privileges --------------+--------------+----------+-------------+-------------+----------------------- arafat | postgres | UTF8 | en_US.UTF-8 | en_US.UTF-8 | postgres | postgres | UTF8 | en_US.UTF-8 | en_US.UTF-8 | template0 | postgres | UTF8 | en_US.UTF-8 | en_US.UTF-8 | =c/postgres + | | | | | postgres=CTc/postgres template1 | postgres | UTF8 | en_US.UTF-8 | en_US.UTF-8 | =c/postgres + | | | | | postgres=CTc/postgres test | arafat | UTF8 | en_US.UTF-8 | en_US.UTF-8 | (5 rows) arafat=# \\c test; You are now connected to database \u0026amp;quot;test\u0026amp;quot; as user \u0026amp;quot;arafat\u0026amp;quot;.    1.3. DROP DATABASE arafat_hasan=# DROP DATABASE test; DROP DATABASE    1.4. CREATE TABLE We have to create a database again as we deleted the test database in the previous step. Here \\d a list of tables, and there is no table in our newly created database.\n arafat=# CREATE DATABASE test; CREATE DATABASE test=# \\d Did not find any relations.   Now here we are creating a new table named person:\n Command\n CREATE TABLE person ( id BIGSERIAL NOT NULL PRIMARY KEY, first_name VARCHAR(50) NOT NULL, last_name VARCHAR(50) NOT NULL, gender VARCHAR(50) NOT NULL, date_of_birth DATE NOT NULL, email VARCHAR(150));   Output\n CREATE TABLE   Now check the list of tables:\n test=# \\d List of relations Schema | Name | Type | Owner --------+---------------+----------+-------------- public | person | table | arafat_hasan public | person_id_seq | sequence | arafat_hasan (2 rows)   person_id_seq is not a table, it is a sequence to maintain and increment the BIGSERIAL value in the person table. The keyword NOT NULL means that this field can not be null or blank, we must have enter data for that field. Someone may not have email, so have kept the field as optional.\n  1.5. Table Definition test=# \\d person; Table \u0026#34;public.person\u0026#34; Column | Type | Collation | Nullable | Default ---------------+------------------------+-----------+----------+------------------------------------ id | bigint | | not null | nextval(\u0026#39;person_id_seq\u0026#39;::regclass) first_name | character varying(50) | | not null | last_name | character varying(50) | | not null | gender | character varying(50) | | not null | date_of_birth | date | | not null | email | character varying(150) | | | Indexes: \u0026#34;person_pkey\u0026#34; PRIMARY KEY, btree (id)    1.6. INSERT INTO Notice that, as email is not NOT NULL so it is optional to insert into the table.\n Command\n INSERT INTO person (first_name, last_name, gender, date_of_birth) VALUES(\u0026#39;Anne\u0026#39;, \u0026#39;Smith\u0026#39;, \u0026#39;female\u0026#39;, DATE \u0026#39;1988-01-09\u0026#39;);   Output\n INSERT 0 1   Command\n INSERT INTO person (first_name, last_name, gender, date_of_birth, email) VALUES(\u0026#39;Jack\u0026#39;, \u0026#39;Doe\u0026#39;, \u0026#39;male\u0026#39;, DATE \u0026#39;1985-11-03\u0026#39;, \u0026#39;jack@example.com\u0026#39;);   Output\n INSERT 0 1    1.7. SELECT Fetch all data from table:\n Command\n SELECT * FROM person;   Output\n  id | first_name | last_name | gender | date_of_birth | email ----+------------+-----------+--------+---------------+------------------ 1 | Anne | Smith | female | 1988-01-09 | 2 | Jack | Doe | male | 1985-11-03 | jack@example.com (2 rows)    1.8. DROP TABLE Now we want to delete our table person.\n test=# DROP TABLE person; DROP TABLE      ","permalink":"https://arafat-hasan.github.io/en/post/postgres-very-first-commands/","tags":["postgresql","note","postgres"],"title":"PostgreSQL: Very First Commands"},{"categories":["professional writings"],"contents":" This writing is actually a draft note made for me so that I myself don’t forget what I have learned. For that, I think this note will be helpful for those who want to learn new Postgres.\n 1. Introduction to PostgreSQL PostgreSQL is a powerful, open source object-relational database system with over 30 years of active development that has earned it a strong reputation for reliability, feature robustness, and performance.\n PostgreSQL has earned a strong reputation for its proven architecture, reliability, data integrity, robust feature set, extensibility, and the dedication of the open source community behind the software to consistently deliver performant and innovative solutions. PostgreSQL runs on all major operating systems, including Linux, UNIX (AIX, BSD, HP-UX, SGI IRIX, Mac OS X, Solaris, Tru64), and Windows.\n  PostgreSQL (/ˈpoʊstɡrɛs ˌkjuː ˈɛl/), also known as Postgres, is a free and open-source relational database management system (RDBMS) emphasizing extensibility and SQL compliance. It was originally named POSTGRES, referring to its origins as a successor to the Ingres database developed at the University of California, Berkeley. In 1996, the project was renamed to PostgreSQL to reflect its support for SQL. After a review in 2007, the development team decided to keep the name PostgreSQL and the alias Postgres.\n  — Wikipedia     2. 🚧 Installation 2.1. Install PostgreSQL in Ubuntu To install PostgreSQL in ubuntu, we have first to refresh our server’s local package index:\n $ sudo apt update   Then, install the Postgres package along with a -contrib package that adds some additional utilities and functionality:\n $ sudo apt install postgresql postgresql-contrib   See More: How To Install PostgreSQL on Ubuntu 20.04\n  2.2. Install PostgreSQL in CentOS 2.2.1. Method 1: PostgreSQL Yum Repository Install the repository RPM:\n $ sudo dnf install https://download.postgresql.org/pub/repos/yum/reporpms/EL-8-x86_64/pgdg-redhat-repo-latest.noarch.rpm   Disable the built-in PostgreSQL module:\n $ sudo dnf -qy module disable postgresql   Install PostgreSQL:\n $ sudo dnf install postgresql12-server   Now PostgreSQL is installed, we have to perform some initialization steps to prepare a new database cluster for PostgreSQL.\n See More: Linux downloads (Red Hat family)\n  2.2.2. Method 2: Using DNF In DNF, CentOS 8’s default package manager, modules are special collections of RPM packages that together make up a larger application. This is intended to make installing packages and their dependencies more intuitive for users.\n List out the available streams for the postgresql module using the dnf command:\n $ sudo dnf module list postgresql   Output\n postgresql 9.6 client, server [d] PostgreSQL server and client module postgresql 10 [d] client, server [d] PostgreSQL server and client module postgresql 12 client, server PostgreSQL server and client module   In this output, we can see three versions of PostgreSQL available from the AppStream repository: 9.6, 10, and 12. The stream that provides Postgres version 10 is the default, as indicated by the [d] following it. If we want to install that version, we could just run sudo dnf install postgresql-server and move on to the next step.\n To install PostgreSQL version 12, we have to enable that version’s module stream. When we enable a module stream, we override the default stream and make all of the packages related to the enabled stream available on the system.\n To enable the module stream for Postgres version 12, run the following command:\n $ sudo dnf module enable postgresql:12   Output\n ==================================================================== Package Architecture Version Repository Size ==================================================================== Enabling module streams: postgresql 12 Transaction Summary ==================================================================== Is this ok [y/N]: y   After enabling the version 12 module stream, we can install the postgresql-server package to install PostgreSQL 12 and all of its dependencies:\n $ sudo dnf install postgresql-server   When given the prompt, confirm the installation by pressing y then ENTER:\n Output\n . . . Install 4 Packages Total download size: 16 M Installed size: 62 M Is this ok [y/N]: y   Now PostgreSQL is installed, we have to perform some initialization steps to prepare a new database cluster for PostgreSQL.\n See More: How To Install and Use PostgreSQL on CentOS 8\n     3. Initial Configuration 3.1. Creating a New PostgreSQL Database Cluster We have to create a new PostgreSQL database cluster before we can start creating tables and loading them with data. A database cluster is a collection of databases that are managed by a single server instance. Creating a database cluster consists of creating the directories in which the database data will be placed, generating the shared catalog tables, and creating the template1 and postgres databases.\n The template1 database is a template of sorts used to create new databases; everything that is stored in template1, even objects we add ourselves, will be placed in new databases when they’re created. The postgres database is a default database designed for use by users, utilities, and third-party applications.\n The Postgres package we installed in the previous step comes with a handy script called postgresql-setup which helps with low-level database cluster administration.\n To create a database cluster, run the script using sudo and with the --initdb option.\n If PostgreSQL is installed using the PostgreSQL Yum repository:\n $ /usr/pgsql-12/bin/postgresql-12-setup initdb   If PostgreSQL is installed using DNF:\n $ sudo postgresql-setup --initdb   Output\n  * Initializing database in \u0026#39;/var/lib/pgsql/data\u0026#39; * Initialized, logs are in /var/lib/pgsql/initdb_postgresql.log   Now start and enable PostgreSQL using systemctl.\n If PostgreSQL is installed using the PostgreSQL Yum repository:\n $ systemctl enable postgresql-12 $ systemctl start postgresql-12   If PostgreSQL is installed using DNF:\n $ sudo systemctl start postgresql $ sudo systemctl enable postgresql   Output\n Created symlink /etc/systemd/system/multi-user.target.wants/postgresql.service → /usr/lib/systemd/system/postgresql.service.   Now that PostgreSQL is up and running, we will go over using roles to learn how Postgres works and how it is different from similar database management systems.\n  3.2. Understanding PostgreSQL Roles and Databases By default, Postgres uses a concept called roles to handle authentication and authorization. These are, in some ways, similar to regular Unix-style accounts, but Postgres does not distinguish between users and groups and instead prefers the more flexible term role.\n Upon installation, Postgres is set up to use ident authentication, meaning that it associates Postgres roles with a matching Unix/Linux system account. If a role exists within Postgres, a Unix/Linux username with the same name can sign in as that role.\n The installation procedure created a user account called postgres that is associated with the default Postgres role. To use Postgres, at first, we have to log in using that role.\n So we have to switch over to the postgres UNIX user, which is created upon installation of Postgres, and then from the postgres UNIX user, we will able to log on Postgres server.\n [arafat@server ~]$ sudo -i -u postgres [postgres@server ~]$ psql   Alternatively, to access a Postgres prompt without switching users\n [arafat@server ~]$ sudo -u postgres psql    3.3. Creating a New Postgres Role To log in with ident-based authentication, we will need a Linux user with the same name as our Postgres role and database.\n If we don’t have a matching Linux user available, we must create one with the adduser command.\n [arafat@server ~]$ sudo adduser postgresuser   We showed how to create a UNIX user named postgresuser here, but we will not use it. Instead, we will use the existing arafat user for a new Postgres roll.\n Now we will create a Postgres role. After switching to postgres Linux user:\n postgres@server:~$ createuser --interactive Enter name of role to add: arafat Shall the new role be a superuser? (y/n) y   Another assumption that the Postgres authentication system makes by default is that for any role used to log in, that role will have a database with the same name which it can access.\n This means that if the user we created in the last section is called arafat, that role will attempt to connect to a database which is also called arafat by default. We can create such a database with the createdb command.\n If we are logged in as the postgres user, we would type something like:\n postgres@server:~$ createdb arafat   Now we will able to connect to psql from unix user arafat to Postgres role arafat.\n [arafat@server ~]$ psql psql (12.3) Type \u0026amp;quot;help\u0026amp;quot; for help. arafat=#      ","permalink":"https://arafat-hasan.github.io/en/post/postgres-intro/","tags":["postgresql","note","postgres"],"title":"PostgreSQL: Introduction and Installation"}]